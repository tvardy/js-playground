{
  "version": 3,
  "sources": ["../node_modules/udomdiff/esm/index.js", "../node_modules/uhandlers/esm/index.js"],
  "sourcesContent": ["/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap \uD83D\uDC4D)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n", "import {isArray} from 'uarray';\n\n// flag for foreign checks (slower path, fast by default)\nlet useForeign = false;\n\nexport class Foreign {\n  constructor(handler, value) {\n    useForeign = true;\n    this._ = (...args) => handler(...args, value);\n  }\n}\n\nexport const foreign = (handler, value) => new Foreign(handler, value);\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        const value = useForeign && (newValue instanceof Foreign) ?\n                        newValue._(node, name) : newValue;\n        if (value == null) {\n          if (!orphan)\n            node.removeAttributeNode(attributeNode);\n            orphan = true;\n        }\n        else {\n          attributeNode.value = value;\n          if (orphan) {\n            node.setAttributeNodeNS(attributeNode);\n            orphan = false;\n          }\n        }\n      }\n    }\n  };\n};\n\nexport const boolean = (node, key, oldValue) => newValue => {\n  if (oldValue !== !!newValue) {\n    // when IE won't be around anymore ...\n    // node.toggleAttribute(key, oldValue = !!newValue);\n    if ((oldValue = !!newValue))\n      node.setAttribute(key, '');\n    else\n      node.removeAttribute(key);\n  }\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, lower, type = name.slice(2);\n  if (!(name in node) && (lower = name.toLowerCase()) in node)\n    type = lower.slice(2);\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => {\n  let oldValue;\n  return value => {\n    if (oldValue !== value) {\n      oldValue = value;\n      if (typeof value === 'function')\n        value(node);\n      else\n        value.current = node;\n    }\n  };\n};\n\nexport const setter = (node, key) => key === 'dataset' ?\n  data(node) :\n  value => {\n    node[key] = value;\n  };\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n"],
  "mappings": "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",
  "names": ["esm_default", "parentNode", "a", "b", "get", "before", "bLength", "aEnd", "bEnd", "aStart", "bStart", "map", "node", "i", "index", "sequence", "useForeign", "Foreign", "handler", "value", "args", "aria", "node", "values", "key", "name", "value", "attribute", "oldValue", "orphan", "attributeNode", "newValue", "useForeign", "Foreign", "boolean", "data", "dataset", "event", "lower", "type", "info", "isArray", "ref", "setter", "text"]
}
