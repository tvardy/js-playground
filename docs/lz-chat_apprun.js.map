{
  "version": 3,
  "sources": ["../node_modules/@webreflection/mapset/esm/index.js", "../node_modules/@webreflection/uparser/esm/index.js", "../node_modules/@webreflection/uwire/esm/index.js", "../node_modules/uhtml/esm/utils.js", "../node_modules/uhtml/esm/handlers.js", "../node_modules/uhtml/esm/rabbit.js", "../node_modules/uhtml/esm/index.js", "../src/js/components/lz-u_login.js", "../src/js/components/lz-u_message.js", "../src/js/components/lz-u_chat.js", "../src/js/lz-chat_apprun.js"],
  "sourcesContent": ["export class MapSet extends Map {\n  set(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\n\nexport class WeakMapSet extends WeakMap {\n  set(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\n", "/*! (c) Andrea Giammarchi - ISC */\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst elements = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} svg enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, svg) => {\n  let i = 0;\n  return template\n          .join('\\x01')\n          .trim()\n          .replace(\n            elements,\n            (_, name, attrs, selfClosing) => {\n              let ml = name + attrs.replace(attributes, '\\x02=$2$1').trimEnd();\n              if (selfClosing.length)\n                ml += (svg || empty.test(name)) ? ' /' : ('></' + name);\n              return '<' + ml + '>';\n            }\n          )\n          .replace(\n            holes,\n            hole => hole === '\\x01' ?\n              ('<!--' + prefix + i++ + '-->') :\n              (prefix + i++)\n          );\n};\n", "const ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {firstChild, lastChild} = fragment;\n  if (firstChild === lastChild)\n    return lastChild || fragment;\n  const {childNodes} = fragment;\n  const nodes = [...childNodes];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== nodes.length)\n        fragment.append(...nodes);\n      return fragment;\n    }\n  };\n};\n", "const {isArray, prototype} = Array;\nconst {indexOf} = prototype;\n\nexport {isArray, indexOf};\n\nconst {\n  createDocumentFragment,\n  createElement,\n  createElementNS,\n  createTextNode,\n  createTreeWalker,\n  importNode\n} = new Proxy(document, {\n  get: (target, method) => target[method].bind(target)\n});\n\nexport {createTextNode, createTreeWalker, importNode};\n\nconst createHTML = html => {\n  const template = createElement('template');\n  template.innerHTML = html;\n  return template.content;\n};\n\nlet xml;\nconst createSVG = svg => {\n  if (!xml) xml = createElementNS('http://www.w3.org/2000/svg', 'svg');\n  xml.innerHTML = svg;\n  const content = createDocumentFragment();\n  content.append(...xml.childNodes);\n  return content;\n};\n\nexport const createContent = (text, svg) => svg ?\n                              createSVG(text) : createHTML(text);\n", "import {diffable} from '@webreflection/uwire';\n\nimport {aria, attribute, boolean, event, ref, setter, text} from 'uhandlers';\nimport udomdiff from 'udomdiff';\n\nimport {isArray, createTextNode} from './utils.js';\n\n// from a generic path, retrieves the exact targeted node\nconst reducePath = ({childNodes}, i) => childNodes[i];\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (!text)\n            text = createTextNode('');\n          text.data = newValue;\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if (oldValue !== newValue && 'ELEMENT_NODE' in newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              [...newValue.childNodes] :\n              [newValue]\n          );\n        }\n        break;\n      case 'function':\n        anyContent(newValue(comment));\n        break;\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * ?boolean=${...} for boolean attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * @event=${...}   to explicitly handle event listeners\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  switch (name[0]) {\n    case '?': return boolean(node, name.slice(1), false);\n    case '.': return setter(node, name.slice(1));\n    case '@': return event(node, 'on' + name.slice(1));\n    case 'o': if (name[1] === 'n') return event(node, name);\n  }\n\n  switch (name) {\n    case 'ref': return ref(node);\n    case 'aria': return aria(node);\n  }\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n", "import {WeakMapSet} from '@webreflection/mapset';\nimport instrument from '@webreflection/uparser';\nimport {persistent} from '@webreflection/uwire';\n\nimport {handlers} from './handlers.js';\nimport {isArray, indexOf, createContent, createTreeWalker, importNode} from './utils.js';\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nconst createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    ({parentNode} = node);\n  }\n  return path;\n};\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// is\u00B5X=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--is\u00B5X-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--is\u00B5X--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'is\u00B5';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = new WeakMapSet;\n\n// a RegExp that helps checking nodes that cannot contain comments\nconst textOnly = /^(?:textarea|script|style|title|plaintext|xmp)$/;\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const svg = type === 'svg';\n  const text = instrument(template, prefix, svg);\n  const content = createContent(text, svg);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createTreeWalker(content, 1 | 128);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div is\u00B50=\"attr\" is\u00B51=\"other\"><!--is\u00B52--><style><!--is\u00B53--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains is\u00B5X\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.data === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named is\u00B5X and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"is\u00B5X\")\n      // the is\u00B5X attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search)\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style, textarea, or others, check its content\n      // and if it is <!--is\u00B5X--> then update tex-only this node\n      if (\n        textOnly.test(node.localName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode(content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  const length = unrollValues(info, values);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values) => {\n  const {length} = values;\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(stack[i] || (stack[i] = createCache()), hole);\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n  return length;\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(type, template, values) {\n    this.type = type;\n    this.template = template;\n    this.values = values;\n  }\n};\n", "import {MapSet, WeakMapSet} from '@webreflection/mapset';\n\nimport {Hole, createCache, unroll} from './rabbit.js';\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = new WeakMapSet;\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return Object.assign(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      // keyed operations need a reference object, usually the parent node\n      // which is showing keyed results, and optionally a unique id per each\n      // related node, handy with JSON results and mutable list of objects\n      // that usually carry a unique identifier\n      for(ref, id) {\n        const memo = keyed.get(ref) || keyed.set(ref, new MapSet);\n        return memo.get(id) || memo.set(id, fixed(createCache()));\n      },\n      // it is possible to create one-off content out of the box via node tag\n      // this might return the single created node, or a fragment with all\n      // nodes present at the root level and, of course, their child nodes\n      node: (template, ...values) => unroll(createCache(), new Hole(type, template, values)).valueOf()\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = new WeakMapSet;\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.replaceChildren(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg};\n", "/* global app */\nimport { html } from 'uhtml'\n\nconst view = html`\n  <form class=\"box wide login\" onSubmit=${(e) => app.run('login', e)}>\n    <input name=\"user\" placeholder=\"Your nickname\" />\n  </form>\n`\n\nexport default view\n", "import { html } from 'uhtml'\n\nconst view = (userId, message) => html`\n  <div\n    class=\"message\"\n    data-self=${message.user.id === userId}\n    data-user=${message.user.name}\n  >\n    ${message.msg}\n  </div>\n`\n\nexport default view\n", "/* global app */\nimport { html } from 'uhtml'\n\nimport Message from './lz-u_message'\n\nconst view = (status, user, messages) => html`\n  <section class=\"box wide chat-box\" data-status=${status}>\n    ${messages.map((message) => Message(user.id, message))}\n  </section>\n  <form class=\"box wide message\" onSubmit=${(e) => app.run('send', e)}>\n    <input name=\"msg\" placeholder=\"message box...\" />\n  </form>\n`\n\nexport default view\n", "/* global app */\nimport { LEVELS, Log } from './tools/Logger'\nimport { render, html } from 'uhtml'\n\nimport { constants, state } from './lz-chat_common'\nimport { wsConnect } from './utils/wsConnect'\nimport { pack, unpack } from './utils/lzip.js'\n\nimport Login from './components/lz-u_login'\nimport Chat from './components/lz-u_chat'\n\nif (process.env.NODE_ENV === 'development') {\n  Log.logLevel = LEVELS.DEBUG\n}\n\nLog.debug('LZ Chat AppRun started!')\n\napp.render = render\nconst rootElem = document.getElementById('apprun')\n\nconst actions = {\n  login (state, e) {\n    e.preventDefault()\n\n    const name = e.target.elements.user.value\n\n    App.run('connecting')\n\n    wsConnect(constants.URL)\n      .then((sock) => {\n        App.sock = sock\n\n        App.sock.on('message', (msg) => {\n          App.run('message', unpack(msg))\n        })\n\n        App.run('connected', { id: sock.id, name })\n      })\n      .catch((e) => {\n        Log.error('WS error:', e)\n\n        App.run('error')\n      })\n  },\n  connecting (state) {\n    return {\n      ...state,\n      status: 'connecting'\n    }\n  },\n  connected (state, user) {\n    Log.debug('AppRun connected:', user)\n\n    return {\n      ...state,\n      status: 'connected',\n      user\n    }\n  },\n  error () {\n    return {\n      ...state,\n      status: 'error'\n    }\n  },\n  send (state, e) {\n    e.preventDefault()\n\n    const msg = e.target.elements.msg.value\n    const data = { user: state.user, msg }\n\n    e.target.elements.msg.value = ''\n\n    Log.debug('AppRun send:', msg)\n\n    App.sock.emit('message', pack(data))\n    App.run('message', data)\n  },\n  message (state, data) {\n    Log.debug('AppRun message:', data.user, data.msg)\n\n    App.run('align')\n\n    return {\n      ...state,\n      messages: state.messages.concat(data)\n    }\n  },\n  align () {\n    const box = rootElem.querySelector('.chat-box')\n\n    setTimeout(() => {\n      if (box.scrollTop < box.scrollHeight) {\n        box.scrollTop = box.scrollHeight\n      }\n    }, 0)\n  }\n}\n\nconst view = (state) =>\n  html`${state.status === 'login'\n    ? Login\n    : Chat(state.status, state.user, state.messages)}`\n\nconst App = app.start(rootElem, state, view, actions)\n"],
  "mappings": "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",
  "names": ["MapSet", "key", "value", "WeakMapSet", "empty", "elements", "attributes", "holes", "esm_default", "template", "prefix", "svg", "i", "_", "name", "attrs", "selfClosing", "ml", "hole", "remove", "firstChild", "lastChild", "range", "diffable", "node", "operation", "persistent", "fragment", "childNodes", "nodes", "isArray", "prototype", "indexOf", "createDocumentFragment", "createElement", "createElementNS", "createTextNode", "createTreeWalker", "importNode", "target", "method", "createHTML", "html", "template", "createElement", "xml", "createSVG", "svg", "createElementNS", "content", "createDocumentFragment", "createContent", "text", "reducePath", "childNodes", "i", "diff", "comment", "oldNodes", "newNodes", "esm_default", "diffable", "handleAnything", "oldValue", "text", "nodes", "anyContent", "newValue", "createTextNode", "isArray", "handleAttribute", "node", "name", "boolean", "setter", "event", "ref", "aria", "attribute", "handlers", "options", "type", "path", "createPath", "node", "path", "parentNode", "indexOf", "prefix", "cache", "WeakMapSet", "textOnly", "createCache", "createEntry", "type", "template", "content", "updates", "mapUpdates", "mapTemplate", "svg", "text", "esm_default", "createContent", "tw", "createTreeWalker", "nodes", "length", "i", "search", "fragment", "importNode", "handlers", "unroll", "info", "values", "unrollValues", "entry", "wire", "persistent", "stack", "hole", "Hole", "isArray", "tag", "type", "keyed", "WeakMapSet", "fixed", "cache", "template", "values", "unroll", "Hole", "ref", "id", "memo", "MapSet", "createCache", "render", "where", "what", "hole", "info", "wire", "html", "svg", "view", "html", "e", "lz_u_login_default", "view", "userId", "message", "html", "lz_u_message_default", "view", "status", "user", "messages", "html", "message", "lz_u_message_default", "e", "lz_u_chat_default", "Log", "render", "rootElem", "actions", "state", "name", "App", "wsConnect", "constants", "sock", "msg", "unpack", "e", "user", "data", "pack", "box", "view", "html", "lz_u_login_default", "lz_u_chat_default"]
}
