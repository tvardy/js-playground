{
  "version": 3,
  "sources": ["../node_modules/umap/esm/index.js", "../node_modules/uparser/esm/index.js", "../node_modules/uarray/esm/index.js", "../node_modules/uwire/esm/index.js", "../node_modules/udomdiff/esm/index.js", "../node_modules/uhandlers/esm/index.js", "../node_modules/uce/node_modules/uhtml/esm/handlers.js", "../node_modules/@ungap/create-content/esm/index.js", "../node_modules/uce/node_modules/uhtml/esm/node.js", "../node_modules/uce/node_modules/uhtml/esm/rabbit.js", "../node_modules/uce/node_modules/uhtml/esm/index.js", "../node_modules/plain-tag/esm/index.js", "../node_modules/reactive-props/esm/utils.js", "../node_modules/reactive-props/esm/dom.js", "../node_modules/uce/esm/index.js", "../src/js/wc-script_common.js", "../src/js/wc-script_uce.js"],
  "sourcesContent": ["export default _ => ({\n  // About: get: _.get.bind(_)\n  // It looks like WebKit/Safari didn't optimize bind at all,\n  // so that using bind slows it down by 60%.\n  // Firefox and Chrome are just fine in both cases,\n  // so let's use the approach that works fast everywhere \uD83D\uDC4D\n  get: key => _.get(key),\n  set: (key, value) => (_.set(key, value), value)\n});\n", "const attr = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)$/;\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst node = /<[a-z][^>]+$/i;\nconst notNode = />[^<>]*$/;\nconst selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/>)/ig;\nconst trimEnd = /\\s+$/;\n\nconst isNode = (template, i) => (\n    0 < i-- && (\n    node.test(template[i]) || (\n      !notNode.test(template[i]) && isNode(template, i)\n    )\n  )\n);\n\nconst regular = (original, name, extra) => empty.test(name) ?\n                  original : `<${name}${extra.replace(trimEnd,'')}></${name}>`;\n\nexport default (template, prefix, svg) => {\n  const text = [];\n  const {length} = template;\n  for (let i = 1; i < length; i++) {\n    const chunk = template[i - 1];\n    text.push(attr.test(chunk) && isNode(template, i) ?\n      chunk.replace(\n        attr,\n        (_, $1, $2) => `${prefix}${i - 1}=${$2 || '\"'}${$1}${$2 ? '' : '\"'}`\n      ) :\n      `${chunk}<!--${prefix}${i - 1}-->`\n    );\n  }\n  text.push(template[length - 1]);\n  const output = text.join('').trim();\n  return svg ? output : output.replace(selfClosing, regular);\n};\n", "const {isArray} = Array;\nconst {indexOf, slice} = [];\n\nexport {isArray, indexOf, slice};\n", "import {slice} from 'uarray';\n\nconst ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {childNodes} = fragment;\n  const {length} = childNodes;\n  if (length < 2)\n    return length ? childNodes[0] : fragment;\n  const nodes = slice.call(childNodes, 0);\n  const firstChild = nodes[0];\n  const lastChild = nodes[length - 1];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== length) {\n        let i = 0;\n        while (i < length)\n          fragment.appendChild(nodes[i++]);\n      }\n      return fragment;\n    }\n  };\n};\n", "/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap \uD83D\uDC4D)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n", "import {isArray} from 'uarray';\n\n// flag for foreign checks (slower path, fast by default)\nlet useForeign = false;\n\nexport class Foreign {\n  constructor(handler, value) {\n    useForeign = true;\n    this._ = (...args) => handler(...args, value);\n  }\n}\n\nexport const foreign = (handler, value) => new Foreign(handler, value);\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        const value = useForeign && (newValue instanceof Foreign) ?\n                        newValue._(node, name) : newValue;\n        if (value == null) {\n          if (!orphan)\n            node.removeAttributeNode(attributeNode);\n            orphan = true;\n        }\n        else {\n          attributeNode.value = value;\n          if (orphan) {\n            node.setAttributeNodeNS(attributeNode);\n            orphan = false;\n          }\n        }\n      }\n    }\n  };\n};\n\nexport const boolean = (node, key, oldValue) => newValue => {\n  if (oldValue !== !!newValue) {\n    // when IE won't be around anymore ...\n    // node.toggleAttribute(key, oldValue = !!newValue);\n    if ((oldValue = !!newValue))\n      node.setAttribute(key, '');\n    else\n      node.removeAttribute(key);\n  }\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, lower, type = name.slice(2);\n  if (!(name in node) && (lower = name.toLowerCase()) in node)\n    type = lower.slice(2);\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => {\n  let oldValue;\n  return value => {\n    if (oldValue !== value) {\n      oldValue = value;\n      if (typeof value === 'function')\n        value(node);\n      else\n        value.current = node;\n    }\n  };\n};\n\nexport const setter = (node, key) => key === 'dataset' ?\n  data(node) :\n  value => {\n    node[key] = value;\n  };\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n", "import {isArray, slice} from 'uarray';\nimport udomdiff from 'udomdiff';\nimport {aria, attribute, boolean, event, ref, setter, text} from 'uhandlers';\nimport {diffable} from 'uwire';\n\n// from a generic path, retrieves the exact targeted node\nconst reducePath = ({childNodes}, i) => childNodes[i];\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (!text)\n            text = document.createTextNode('');\n          text.data = newValue;\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if (oldValue !== newValue && 'ELEMENT_NODE' in newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              slice.call(newValue.childNodes) :\n              [newValue]\n          );\n        }\n        break;\n      case 'function':\n        anyContent(newValue(comment));\n        break;\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * ?boolean=${...} for boolean attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * @event=${...}   to explicitly handle event listeners\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  switch (name[0]) {\n    case '?': return boolean(node, name.slice(1), false);\n    case '.': return setter(node, name.slice(1));\n    case '@': return event(node, 'on' + name.slice(1));\n    case 'o': if (name[1] === 'n') return event(node, name);\n  }\n\n  switch (name) {\n    case 'ref': return ref(node);\n    case 'aria': return aria(node);\n  }\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n", "/*! (c) Andrea Giammarchi - ISC */\nvar createContent = (function (document) {'use strict';\n  var FRAGMENT = 'fragment';\n  var TEMPLATE = 'template';\n  var HAS_CONTENT = 'content' in create(TEMPLATE);\n\n  var createHTML = HAS_CONTENT ?\n    function (html) {\n      var template = create(TEMPLATE);\n      template.innerHTML = html;\n      return template.content;\n    } :\n    function (html) {\n      var content = create(FRAGMENT);\n      var template = create(TEMPLATE);\n      var childNodes = null;\n      if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n        var selector = RegExp.$1;\n        template.innerHTML = '<table>' + html + '</table>';\n        childNodes = template.querySelectorAll(selector);\n      } else {\n        template.innerHTML = html;\n        childNodes = template.childNodes;\n      }\n      append(content, childNodes);\n      return content;\n    };\n\n  return function createContent(markup, type) {\n    return (type === 'svg' ? createSVG : createHTML)(markup);\n  };\n\n  function append(root, childNodes) {\n    var length = childNodes.length;\n    while (length--)\n      root.appendChild(childNodes[0]);\n  }\n\n  function create(element) {\n    return element === FRAGMENT ?\n      document.createDocumentFragment() :\n      document.createElementNS('http://www.w3.org/1999/xhtml', element);\n  }\n\n  // it could use createElementNS when hasNode is there\n  // but this fallback is equally fast and easier to maintain\n  // it is also battle tested already in all IE\n  function createSVG(svg) {\n    var content = create(FRAGMENT);\n    var template = create('div');\n    template.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + svg + '</svg>';\n    append(content, template.firstChild.childNodes);\n    return content;\n  }\n\n}(document));\nexport default createContent;\n", "import createContent from '@ungap/create-content';\n\n// this \"hack\" tells the library if the browser is IE11 or old Edge\nconst isImportNodeLengthWrong = document.importNode.length != 1;\n\n// IE11 and old Edge discard empty nodes when cloning, potentially\n// resulting in broken paths to find updates. The workaround here\n// is to import once, upfront, the fragment that will be cloned\n// later on, so that paths are retrieved from one already parsed,\n// hence without missing child nodes once re-cloned.\nexport const createFragment = isImportNodeLengthWrong ?\n  (text, type, normalize) => document.importNode(\n    createContent(text, type, normalize),\n    true\n  ) :\n  createContent;\n\n// IE11 and old Edge have a different createTreeWalker signature that\n// has been deprecated in other browsers. This export is needed only\n// to guarantee the TreeWalker doesn't show warnings and, ultimately, works\nexport const createWalker = isImportNodeLengthWrong ?\n  fragment => document.createTreeWalker(fragment, 1 | 128, null, false) :\n  fragment => document.createTreeWalker(fragment, 1 | 128);\n", "import umap from 'umap';\nimport instrument from 'uparser';\nimport {indexOf, isArray} from 'uarray';\nimport {persistent} from 'uwire';\n\nimport {handlers} from './handlers.js';\nimport {createFragment, createWalker} from './node.js';\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nconst createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    parentNode = node.parentNode;\n  }\n  return path;\n};\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// is\u00B5X=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--is\u00B5X-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--is\u00B5X--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'is\u00B5';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = umap(new WeakMap);\n\n// a RegExp that helps checking nodes that cannot contain comments\nconst textOnly = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const text = instrument(template, prefix, type === 'svg');\n  const content = createFragment(text, type);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createWalker(content);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div is\u00B50=\"attr\" is\u00B51=\"other\"><!--is\u00B52--><style><!--is\u00B53--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains is\u00B5X\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.data === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named is\u00B5X and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"is\u00B5X\")\n      // the is\u00B5X attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search),\n          //svg: svg < 0 ? (svg = ('ownerSVGElement' in node ? 1 : 0)) : svg\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style, textarea, or others, check its content\n      // and if it is <!--is\u00B5X--> then update tex-only this node\n      if (\n        textOnly.test(node.tagName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = document.importNode(content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  const {length} = values;\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  unrollValues(info, values, length);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values, length) => {\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(\n        stack[i] || (stack[i] = createCache()),\n        hole,\n        hole.length\n      );\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport function Hole(type, template, values) {\n  this.type = type;\n  this.template = template;\n  this.values = values;\n};\n", "import umap from 'umap';\nimport {Hole, createCache, unroll} from './rabbit.js';\nimport {foreign} from 'uhandlers';\n\nconst {create, defineProperties} = Object;\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = umap(new WeakMap);\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return defineProperties(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      for: {\n        // keyed operations need a reference object, usually the parent node\n        // which is showing keyed results, and optionally a unique id per each\n        // related node, handy with JSON results and mutable list of objects\n        // that usually carry a unique identifier\n        value(ref, id) {\n          const memo = keyed.get(ref) || keyed.set(ref, create(null));\n          return memo[id] || (memo[id] = fixed(createCache()));\n        }\n      },\n      node: {\n        // it is possible to create one-off content out of the box via node tag\n        // this might return the single created node, or a fragment with all\n        // nodes present at the root level and, of course, their child nodes\n        value: (template, ...values) => unroll(\n          createCache(),\n          {type, template, values}\n        ).valueOf()\n      }\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = umap(new WeakMap);\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    where.textContent = '';\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.appendChild(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg, foreign};\n", "export default function (t) {\n  for (var s = t[0], i = 1, l = arguments.length; i < l; i++)\n    s += arguments[i] + t[i];\n  return s;\n};\n", "const {defineProperties, keys} = Object;\n\nconst accessor = (all, shallow, hook, value, update) => ({\n  configurable: true,\n  get: () => value,\n  set(_) {\n    if (all || _ !== value || (shallow && typeof _ === 'object' && _)) {\n      value = _;\n      if (hook)\n        update.call(this, value);\n      else\n        update.call(this);\n    }\n  }\n});\n\nconst loop = (props, get, all, shallow, useState, update) => {\n  const desc = {};\n  const hook = useState !== noop;\n  const args = [all, shallow, hook];\n  for (let ke = keys(props), y = 0; y < ke.length; y++) {\n    const value = get(props, ke[y]);\n    const extras = hook ? useState(value) : [value, useState];\n    if (update)\n      extras[1] = update;\n    desc[ke[y]] = accessor.apply(null, args.concat(extras));\n  }\n  return desc;\n};\n\nconst noop = () => {};\n\nexport {defineProperties, loop, noop};\n", "import {defineProperties, loop, noop} from './utils.js';\n\nexport default ({\n  all = false,\n  shallow = true,\n  useState = noop,\n  getAttribute = (element, key) => element.getAttribute(key)\n} = {}) => (element, props, update) => {\n  const value = (props, key) => {\n    let result = props[key], type = typeof result;\n    if (element.hasOwnProperty(key)) {\n      result = element[key];\n      delete element[key];\n    }\n    else if (element.hasAttribute(key)) {\n      result = getAttribute(element, key);\n      if (type == 'number')\n        result = +result;\n      else if (type == 'boolean')\n        result = !/^(?:false|0|)$/.test(result);\n    }\n    return result;\n  };\n  const desc = loop(props, value, all, shallow, useState, update);\n  return defineProperties(element, desc);\n};\n", "import {render, html, svg} from 'uhtml';\nimport umap from 'umap';\nimport css from 'plain-tag';\n\nimport domHandler from 'reactive-props/esm/dom.js';\nconst reactive = domHandler({dom: true});\n\nconst CE = customElements;\nconst {define: defineCustomElement} = CE;\nconst {parse, stringify} = JSON;\nconst {create, defineProperties, getOwnPropertyDescriptor, keys} = Object;\n\nconst element = 'element';\nconst ownProps = new WeakMap;\nconst constructors = umap(new Map([[element, {c: HTMLElement, e: element}]]));\n\nconst el = name => document.createElement(name);\n\nconst info = e => constructors.get(e) || constructors.set(e, {\n  c: el(e).constructor,\n  e\n});\n\nconst define = (tagName, definition) => {\n  const {\n    attachShadow,\n    attributeChanged,\n    bound,\n    connected,\n    disconnected,\n    handleEvent,\n    init,\n    observedAttributes,\n    props,\n    render,\n    style\n  } = definition;\n  const initialized = new WeakMap;\n  const statics = {};\n  const proto = {};\n  const listeners = [];\n  const retype = create(null);\n  const bootstrap = (element, key, value) => {\n    if (!initialized.has(element)) {\n      initialized.set(element, 0);\n      defineProperties(element, {\n        html: {\n          configurable: true,\n          value: content.bind(\n            attachShadow ? element.attachShadow(attachShadow) : element\n          )\n        }\n      });\n      for (let i = 0; i < length; i++) {\n        const {type, options} = listeners[i];\n        element.addEventListener(type, element, options);\n      }\n      if (bound)\n        bound.forEach(bind, element);\n      if (props) {\n        const reProps = {};\n        for (let k = keys(props), i = 0; i < k.length; i++) {\n          const key = k[i];\n          const value = props[key];\n          reProps[key] = typeof value === 'object' ? parse(stringify(value)) : value;\n        }\n        ownProps.set(element, reProps);\n        reactive(element, reProps, render);\n      }\n      if (init || render)\n        (init || render).call(element);\n      if (key)\n        element[key] = value;\n    }\n  };\n  for (let k = keys(definition), i = 0, {length} = k; i < length; i++) {\n    const key = k[i];\n    if (/^on./.test(key) && !/Options$/.test(key)) {\n      const options = definition[key + 'Options'] || false;\n      const lower = key.toLowerCase();\n      let type = lower.slice(2);\n      listeners.push({type, options});\n      retype[type] = key;\n      if (lower !== key) {\n        type = lower.slice(2, 3) + key.slice(3);\n        retype[type] = key;\n        listeners.push({type, options});\n      }\n    }\n    switch (key) {\n      case 'attachShadow':\n      case 'constructor':\n      case 'observedAttributes':\n      case 'style':\n        break;\n      default:\n        proto[key] = getOwnPropertyDescriptor(definition, key);\n    }\n  }\n  const {length} = listeners;\n  if (length && !handleEvent)\n    proto.handleEvent = {value(event) {\n      this[retype[event.type]](event);\n    }};\n\n  // [props]\n  if (props !== null) {\n    if (props) {\n      for (let k = keys(props), i = 0; i < k.length; i++) {\n        const key = k[i];\n        proto[key] = {\n          get() {\n            bootstrap(this);\n            return ownProps.get(this)[key];\n          },\n          set(value) {\n            bootstrap(this, key, value);\n          }\n        };\n      }\n    }\n    else {\n      proto.props = {get() {\n        const props = {};\n        for (let {attributes} = this, {length} = attributes, i = 0; i < length; i++) {\n          const {name, value} = attributes[i];\n          props[name] = value;\n        }\n        return props;\n      }};\n    }\n  }\n  // [/props]\n\n  if (observedAttributes)\n    statics.observedAttributes = {value: observedAttributes};\n  proto.attributeChangedCallback =  {value() {\n    bootstrap(this);\n    if (attributeChanged)\n      attributeChanged.apply(this, arguments);\n  }};\n\n  proto.connectedCallback = {value() {\n    bootstrap(this);\n    if (connected)\n      connected.call(this);\n  }};\n\n  if (disconnected)\n    proto.disconnectedCallback = {value: disconnected};\n\n  const {c, e} = info(definition.extends || element);\n  class MicroElement extends c {};\n  defineProperties(MicroElement, statics);\n  defineProperties(MicroElement.prototype, proto);\n  const args = [tagName, MicroElement];\n  if (e !== element)\n    args.push({extends: e});\n  defineCustomElement.apply(CE, args);\n  constructors.set(tagName, {c: MicroElement, e});\n  if (style)\n    document.head.appendChild(el('style')).textContent = style(\n      e === element ? tagName : (e + '[is=\"' + tagName + '\"]')\n    );\n  return MicroElement;\n};\n\nexport {define, render, html, svg, css};\n\n/* istanbul ignore else */\nif (!CE.get('uce-lib'))\n  // theoretically this could be just class { ... }\n  // however, if there is for whatever reason a <uce-lib>\n  // element on the page, it will break once the registry\n  // will try to upgrade such element so ... HTMLElement it is.\n  CE.define('uce-lib', class extends info(element).c {\n    static get define() { return define; }\n    static get render() { return render; }\n    static get html() { return html; }\n    static get svg() { return svg; }\n    static get css() { return css; }\n  });\n\nfunction bind(method) {\n  this[method] = this[method].bind(this);\n}\n\nfunction content() {\n  return render(this, html.apply(null, arguments));\n}\n", "export const start = (element, position = 'beforeend') => {\n  const selector = element.dataset.target\n  const where = selector ? document.querySelector(selector) : document.body\n  const what = element.text.trim().replace(/\\n\\s+/gm, '')\n\n  where.insertAdjacentHTML(position, what)\n}\n", "import { define, css } from 'uce'\nimport { start } from './wc-script_common'\n\ndefine('simple-component-uce', {\n  style: (selector) => css`\n    ${selector} {\n      display: block;\n      padding: 2em;\n      background: lightpink;\n      color: var(--shade2);\n      text-align: center;\n      cursor: pointer;\n    }\n    ${selector}.active {\n      background: var(--shade1);\n      color: var(--shade0);\n    }\n    ${selector}.active > * {\n      color: inherit;\n    }\n    ${selector} h1 {\n      color: var(--shade1);\n    }\n    ${selector} p {\n      font-size: 0.8em;\n      text-transform: uppercase;\n    }\n  `,\n  render () {\n    this.html`\n      <h1>${this.props.title}</h1>\n      <pre>Clicked: ${this.count} times</pre>\n      ${Array.from(this.children)}\n    `\n  },\n  count: 0,\n  onClick (event) {\n    this.classList.toggle('active')\n    this.count++\n    this.render()\n  }\n})\n\nstart(document.currentScript)\n"],
  "mappings": "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",
  "names": ["esm_default", "_", "key", "value", "attr", "empty", "node", "notNode", "selfClosing", "trimEnd", "isNode", "template", "i", "regular", "original", "name", "extra", "esm_default", "prefix", "svg", "text", "length", "chunk", "_", "$1", "$2", "output", "isArray", "indexOf", "slice", "ELEMENT_NODE", "nodeType", "remove", "firstChild", "lastChild", "range", "diffable", "node", "operation", "persistent", "fragment", "childNodes", "length", "nodes", "slice", "i", "esm_default", "parentNode", "a", "b", "get", "before", "bLength", "aEnd", "bEnd", "aStart", "bStart", "map", "node", "i", "index", "sequence", "useForeign", "Foreign", "handler", "value", "args", "aria", "node", "values", "key", "name", "value", "attribute", "oldValue", "orphan", "attributeNode", "newValue", "useForeign", "Foreign", "boolean", "data", "dataset", "event", "lower", "type", "info", "isArray", "ref", "setter", "text", "reducePath", "childNodes", "i", "diff", "comment", "oldNodes", "newNodes", "esm_default", "diffable", "handleAnything", "oldValue", "text", "nodes", "anyContent", "newValue", "isArray", "slice", "handleAttribute", "node", "name", "boolean", "setter", "event", "ref", "aria", "attribute", "handlers", "options", "type", "path", "createContent", "document", "FRAGMENT", "TEMPLATE", "HAS_CONTENT", "create", "createHTML", "html", "template", "content", "childNodes", "selector", "append", "markup", "type", "createSVG", "root", "length", "element", "svg", "esm_default", "isImportNodeLengthWrong", "createFragment", "text", "type", "normalize", "esm_default", "createWalker", "fragment", "createPath", "node", "path", "parentNode", "indexOf", "prefix", "cache", "esm_default", "textOnly", "createCache", "createEntry", "type", "template", "content", "updates", "mapUpdates", "mapTemplate", "text", "createFragment", "tw", "createWalker", "nodes", "length", "i", "search", "fragment", "handlers", "unroll", "info", "values", "unrollValues", "entry", "wire", "persistent", "stack", "hole", "Hole", "isArray", "create", "defineProperties", "tag", "type", "keyed", "esm_default", "fixed", "cache", "template", "values", "unroll", "Hole", "ref", "id", "memo", "createCache", "render", "where", "what", "hole", "info", "wire", "html", "svg", "esm_default", "s", "i", "l", "defineProperties", "keys", "accessor", "all", "shallow", "hook", "value", "update", "_", "loop", "props", "get", "useState", "desc", "noop", "args", "ke", "y", "extras", "dom_default", "all", "shallow", "useState", "noop", "getAttribute", "element", "key", "props", "update", "desc", "loop", "result", "type", "defineProperties", "reactive", "dom_default", "CE", "defineCustomElement", "parse", "stringify", "create", "defineProperties", "getOwnPropertyDescriptor", "keys", "element", "ownProps", "constructors", "esm_default", "el", "name", "info", "e", "define", "tagName", "definition", "attachShadow", "attributeChanged", "bound", "connected", "disconnected", "handleEvent", "init", "observedAttributes", "props", "render", "style", "initialized", "statics", "proto", "listeners", "retype", "bootstrap", "key", "value", "content", "i", "length", "type", "options", "bind", "reProps", "k", "lower", "event", "attributes", "c", "MicroElement", "args", "CE", "info", "element", "define", "render", "html", "svg", "esm_default", "bind", "method", "content", "start", "element", "position", "selector", "where", "what", "define", "selector", "esm_default", "event", "start"]
}
