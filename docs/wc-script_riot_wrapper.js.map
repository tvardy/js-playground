{
  "version": 3,
  "sources": ["../node_modules/riot/node_modules/@riotjs/util/checks.js", "../node_modules/riot/node_modules/@riotjs/util/constants.js", "../node_modules/riot/node_modules/@riotjs/util/strings.js", "../node_modules/riot/node_modules/@riotjs/util/dom.js", "../node_modules/riot/node_modules/@riotjs/util/functions.js", "../node_modules/riot/node_modules/@riotjs/util/misc.js", "../node_modules/riot/node_modules/@riotjs/util/objects.js", "../node_modules/riot/esm/core/pure-component-api.js", "../node_modules/riot/esm/core/mocked-template-interface.js", "../node_modules/@riotjs/dom-bindings/node_modules/@riotjs/util/strings.js", "../node_modules/@riotjs/dom-bindings/node_modules/@riotjs/util/dom.js", "../node_modules/@riotjs/dom-bindings/node_modules/@riotjs/util/constants.js", "../node_modules/@riotjs/dom-bindings/node_modules/@riotjs/util/binding-types.js", "../node_modules/@riotjs/dom-bindings/node_modules/@riotjs/util/expression-types.js", "../node_modules/@riotjs/dom-bindings/node_modules/@riotjs/util/objects.js", "../node_modules/@riotjs/dom-bindings/node_modules/@riotjs/util/checks.js", "../node_modules/@riotjs/dom-bindings/node_modules/@riotjs/util/misc.js", "../node_modules/@riotjs/dom-bindings/dist/esm.dom-bindings.js", "../node_modules/riot/esm/core/create-children-components-object.js", "../node_modules/riot/esm/core/component-template-factory.js", "../node_modules/riot/esm/core/bind-dom-node-to-component-instance.js", "../node_modules/riot/esm/core/create-core-api-methods.js", "../node_modules/riot/esm/core/create-pure-component.js", "../node_modules/bianco.dom-to-array/index.next.js", "../node_modules/bianco.query/index.next.js", "../node_modules/riot/esm/core/component-dom-selectors.js", "../node_modules/riot/esm/core/component-lifecycle-methods.js", "../node_modules/bianco.attr/index.next.js", "../node_modules/riot/esm/core/css-manager.js", "../node_modules/curri/index.next.js", "../node_modules/riot/esm/utils/dom.js", "../node_modules/riot/esm/core/add-css-hook.js", "../node_modules/riot/esm/core/compute-component-state.js", "../node_modules/riot/esm/core/compute-initial-props.js", "../node_modules/riot/esm/core/create-attribute-bindings.js", "../node_modules/riot/esm/core/run-plugins.js", "../node_modules/riot/esm/core/manage-component-lifecycle.js", "../node_modules/riot/esm/core/instantiate-component.js", "../node_modules/riot/esm/core/create-component-from-wrapper.js", "../node_modules/riot/esm/api/register.js", "../node_modules/riot/esm/core/mount-component.js", "../node_modules/riot/esm/api/mount.js", "../src/js/wc-script_riot_wrapper.js"],
  "sourcesContent": ["/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nexport function checkType(element, type) {\n  return typeof element === type\n}\n\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\nexport function isSvg(el) {\n  const owner = el.ownerSVGElement\n\n  return !!owner || owner === null\n}\n\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\nexport function isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\nexport function isFunction(value) {\n  return checkType(value, 'function')\n}\n\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\nexport function isBoolean(value) {\n  return checkType(value, 'boolean')\n}\n\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\nexport function isObject(value) {\n  return !isNil(value) && value.constructor === Object\n}\n\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\nexport function isNil(value) {\n  return value === null || value === undefined\n}\n\n/**\n * Detect node js environements\n * @returns {boolean} true if the runtime is node\n */\nexport function isNode() {\n  return typeof process !== 'undefined'\n}\n", "// Riot.js constants that can be used accross more modules\n\nexport const\n  COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n  DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n  PLUGINS_SET = new Set(),\n  IS_DIRECTIVE = 'is',\n  VALUE_ATTRIBUTE = 'value',\n  MOUNT_METHOD_KEY = 'mount',\n  UPDATE_METHOD_KEY = 'update',\n  UNMOUNT_METHOD_KEY = 'unmount',\n  SHOULD_UPDATE_KEY = 'shouldUpdate',\n  ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n  ON_MOUNTED_KEY = 'onMounted',\n  ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n  ON_UPDATED_KEY = 'onUpdated',\n  ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n  ON_UNMOUNTED_KEY = 'onUnmounted',\n  PROPS_KEY = 'props',\n  STATE_KEY = 'state',\n  SLOTS_KEY = 'slots',\n  ROOT_KEY = 'root',\n  IS_PURE_SYMBOL = Symbol('pure'),\n  IS_COMPONENT_UPDATING = Symbol('is_updating'),\n  PARENT_KEY_SYMBOL = Symbol('parent'),\n  ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n  TEMPLATE_KEY_SYMBOL = Symbol('template')\n", "/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nexport function camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nexport function dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase())\n}", "import {dashToCamelCase} from './strings.js'\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\nexport function DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value\n    return acc\n  }, {})\n}\n\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method \u00AF\\_(\u30C4)_/\u00AF\n */\n\n// Ignore this helper because it's needed only for svg tags\nexport function moveChildren(source, target) {\n  target.replaceChildren(...source.childNodes)\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nexport function cleanNode(node) {\n  // eslint-disable-next-line fp/no-loops\n  while (node.firstChild) node.removeChild(node.firstChild)\n}\n\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\nexport function clearChildren(children) {\n  // eslint-disable-next-line fp/no-loops,fp/no-let\n  for (let i = 0;i < children.length; i++) removeChild(children[i])\n}\n\n\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\nexport const removeChild = node => node && node.parentNode && node.parentNode.removeChild(node)\n\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\nexport const insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode)\n\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\nexport const replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced)\n", "import {isFunction} from './checks.js'\n\n// does simply nothing\nexport function noop() {\n  return this\n}\n\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\nexport function autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source)\n  })\n\n  return source\n}\n\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\nexport function callOrAssign(source) {\n  return isFunction(source) ? (source.prototype && source.prototype.constructor ?\n    new source() : source()\n  ) : source\n}\n", "import {ATTRIBUTE, VALUE} from './expression-types.js'\nimport {dashToCamelCase} from './strings.js'\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\nexport function panic(message) {\n  throw new Error(message)\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\nexport function memoize(fn) {\n  const cache = new Map()\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val)\n  }\n  cached.cache = cache\n  return cached\n}\n\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\nexport function evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {value, type} = attribute\n\n    switch (true) {\n    // spread attribute\n    case !attribute.name && type === ATTRIBUTE:\n      return {\n        ...acc,\n        ...value\n      }\n    // value attribute\n    case type === VALUE:\n      acc.value = attribute.value\n      break\n    // normal attributes\n    default:\n      acc[dashToCamelCase(attribute.name)] = attribute.value\n    }\n\n    return acc\n  }, {})\n}\n", "\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nexport function defineProperty(source, key, value, options = {}) {\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, {\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    ...options\n  })\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source\n}\n\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\nexport function defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(([key, value]) => {\n    defineProperty(source, key, value, options)\n  })\n\n  return source\n}\n\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\nexport function defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(([key, value]) => {\n    if (!source[key]) source[key] = value\n  })\n\n  return source\n}\n\n/**\n * Simple clone deep function, do not use it for classes or recursive objects!\n * @param   {*} source - possibily an object to clone\n * @returns {*} the object we wanted to clone\n */\nexport function cloneDeep(source) {\n  return JSON.parse(JSON.stringify(source))\n}\n", "/* Riot WIP, @license MIT */\nimport { MOUNT_METHOD_KEY, noop, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '@riotjs/util';\n\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\n\nexport { PURE_COMPONENT_API };\n", "/* Riot WIP, @license MIT */\nimport { PURE_COMPONENT_API } from './pure-component-api.js';\nimport { noop } from '@riotjs/util';\n\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n\nexport { MOCKED_TEMPLATE_INTERFACE };\n", "/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nexport function camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\nexport function dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase())\n}", "import {dashToCamelCase} from './strings.js'\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\nexport function DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value\n    return acc\n  }, {})\n}\n\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method \u00AF\\_(\u30C4)_/\u00AF\n */\n\n// Ignore this helper because it's needed only for svg tags\nexport function moveChildren(source, target) {\n  target.replaceChildren(...source.childNodes)\n}\n\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\nexport function cleanNode(node) {\n  // eslint-disable-next-line fp/no-loops\n  while (node.firstChild) node.removeChild(node.firstChild)\n}\n\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\nexport function clearChildren(children) {\n  // eslint-disable-next-line fp/no-loops,fp/no-let\n  for (let i = 0;i < children.length; i++) removeChild(children[i])\n}\n\n\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\nexport const removeChild = node => node && node.parentNode && node.parentNode.removeChild(node)\n\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\nexport const insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode)\n\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\nexport const replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced)\n", "// Riot.js constants that can be used accross more modules\n\nexport const\n  COMPONENTS_IMPLEMENTATION_MAP = new Map(),\n  DOM_COMPONENT_INSTANCE_PROPERTY = Symbol('riot-component'),\n  PLUGINS_SET = new Set(),\n  IS_DIRECTIVE = 'is',\n  VALUE_ATTRIBUTE = 'value',\n  MOUNT_METHOD_KEY = 'mount',\n  UPDATE_METHOD_KEY = 'update',\n  UNMOUNT_METHOD_KEY = 'unmount',\n  SHOULD_UPDATE_KEY = 'shouldUpdate',\n  ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n  ON_MOUNTED_KEY = 'onMounted',\n  ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n  ON_UPDATED_KEY = 'onUpdated',\n  ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n  ON_UNMOUNTED_KEY = 'onUnmounted',\n  PROPS_KEY = 'props',\n  STATE_KEY = 'state',\n  SLOTS_KEY = 'slots',\n  ROOT_KEY = 'root',\n  IS_PURE_SYMBOL = Symbol('pure'),\n  IS_COMPONENT_UPDATING = Symbol('is_updating'),\n  PARENT_KEY_SYMBOL = Symbol('parent'),\n  ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n  TEMPLATE_KEY_SYMBOL = Symbol('template')\n", "export const EACH = 0\nexport const IF = 1\nexport const SIMPLE = 2\nexport const TAG = 3\nexport const SLOT = 4\n\nexport default {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n}", "export const ATTRIBUTE = 0\nexport const EVENT = 1\nexport const TEXT = 2\nexport const VALUE = 3\n\nexport default {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n}", "\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nexport function defineProperty(source, key, value, options = {}) {\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, {\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    ...options\n  })\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source\n}\n\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\nexport function defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(([key, value]) => {\n    defineProperty(source, key, value, options)\n  })\n\n  return source\n}\n\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\nexport function defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(([key, value]) => {\n    if (!source[key]) source[key] = value\n  })\n\n  return source\n}\n\n/**\n * Simple clone deep function, do not use it for classes or recursive objects!\n * @param   {*} source - possibily an object to clone\n * @returns {*} the object we wanted to clone\n */\nexport function cloneDeep(source) {\n  return JSON.parse(JSON.stringify(source))\n}\n", "/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nexport function checkType(element, type) {\n  return typeof element === type\n}\n\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\nexport function isSvg(el) {\n  const owner = el.ownerSVGElement\n\n  return !!owner || owner === null\n}\n\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\nexport function isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template'\n}\n\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\nexport function isFunction(value) {\n  return checkType(value, 'function')\n}\n\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\nexport function isBoolean(value) {\n  return checkType(value, 'boolean')\n}\n\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\nexport function isObject(value) {\n  return !isNil(value) && value.constructor === Object\n}\n\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\nexport function isNil(value) {\n  return value === null || value === undefined\n}\n\n/**\n * Detect node js environements\n * @returns {boolean} true if the runtime is node\n */\nexport function isNode() {\n  return typeof process !== 'undefined'\n}\n", "import {ATTRIBUTE, VALUE} from './expression-types.js'\nimport {dashToCamelCase} from './strings.js'\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\nexport function panic(message) {\n  throw new Error(message)\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\nexport function memoize(fn) {\n  const cache = new Map()\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val)\n  }\n  cached.cache = cache\n  return cached\n}\n\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\nexport function evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {value, type} = attribute\n\n    switch (true) {\n    // spread attribute\n    case !attribute.name && type === ATTRIBUTE:\n      return {\n        ...acc,\n        ...value\n      }\n    // value attribute\n    case type === VALUE:\n      acc.value = attribute.value\n      break\n    // normal attributes\n    default:\n      acc[dashToCamelCase(attribute.name)] = attribute.value\n    }\n\n    return acc\n  }, {})\n}\n", "import { insertBefore, removeChild, replaceChild, cleanNode, moveChildren, clearChildren } from '@riotjs/util/dom';\nimport { PARENT_KEY_SYMBOL, IS_PURE_SYMBOL } from '@riotjs/util/constants';\nimport { IF, SIMPLE, EACH, TAG, SLOT } from '@riotjs/util/binding-types';\nexport { default as bindingTypes } from '@riotjs/util/binding-types';\nimport { ATTRIBUTE, EVENT, TEXT, VALUE } from '@riotjs/util/expression-types';\nexport { default as expressionTypes } from '@riotjs/util/expression-types';\nimport { defineProperty } from '@riotjs/util/objects';\nimport { isTemplate, isBoolean, isObject, isFunction, isNil, isSvg } from '@riotjs/util/checks';\nimport { memoize, evaluateAttributeExpressions, panic } from '@riotjs/util/misc';\n\nconst HEAD_SYMBOL = Symbol();\nconst TAIL_SYMBOL = Symbol();\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n\n  return {head, tail}\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const {head, tail} = createHeadTailPlaceholders();\n\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail]\n  }\n}\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nconst udomdiff = (a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap \uD83D\uDC4D)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\n\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const {placeholder, nodes, childrenMap} = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : [];\n\n    // prepare the diffing\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this);\n\n    // patch the DOM only if there are new nodes\n    udomdiff(\n      nodes,\n      futureNodes,\n      patch(\n        Array.from(childrenMap.values()),\n        parentScope\n      ),\n      placeholder\n    );\n\n    // trigger the mounts and the updates\n    batches.forEach(fn => fn());\n\n    // update the children map\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n\n    return this\n  }\n};\n\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const {template, nodes, context} = element;\n        // remove the last node (notice <template> tags might have more children nodes)\n        nodes.pop();\n\n        // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item\n  }\n}\n\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false\n}\n\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\nfunction extendScope(scope, {itemName, indexName, index, item}) {\n  defineProperty(scope, itemName, item);\n  if (indexName) defineProperty(scope, indexName, index);\n\n  return scope\n}\n\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\nfunction createPatch(items, scope, parentScope, binding) {\n  const {condition, template, childrenMap, itemName, getKey, indexName, root, isTemplateTag} = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {itemName, indexName, index, item});\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    }\n\n    // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n    if (isTemplateTag) {\n      nodes.push(...meta.children);\n    } else {\n      nodes.push(el);\n    }\n\n    // delete the old item from the children map\n    childrenMap.delete(key);\n    futureNodes.push(...nodes);\n\n    // update the children map\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  }\n}\n\nfunction create$6(node, {evaluate, condition, itemName, indexName, getKey, template}) {\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n\n  insertBefore(placeholder,  node);\n  removeChild(node);\n\n  return {\n    ...EachBinding,\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  }\n}\n\n/**\n * Binding responsible for the `if` directive\n */\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope)\n  },\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n    case mustMount:\n      mount();\n      break\n    case mustUnmount:\n      this.unmount(scope);\n      break\n    default:\n      if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n\n    return this\n  },\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n\n    return this\n  }\n};\n\nfunction create$5(node, { evaluate, template }) {\n  const placeholder = document.createTextNode('');\n\n  insertBefore(placeholder, node);\n  removeChild(node);\n\n  return {\n    ...IfBinding,\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  }\n}\n\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name) ); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\nfunction setAllAttributes(node, attributes) {\n  Object\n    .entries(attributes)\n    .forEach(([name, value]) => attributeExpression(node, { name }, value));\n}\n\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n\n  Object\n    .keys(oldAttributes)\n    .filter(name => !newKeys.includes(name))\n    .forEach(attribute => node.removeAttribute(attribute));\n}\n\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\nfunction canRenderAttribute(value) {\n  return value === true || ['string', 'number'].includes(typeof value)\n}\n\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\nfunction shouldRemoveAttribute(value) {\n  return !value && value !== 0\n}\n\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\nfunction attributeExpression(node, { name }, value, oldValue) {\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    }\n\n    // is the value still truthy?\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return\n  }\n\n  // handle boolean attributes\n  if (\n    !isNativeHtmlProperty(name) && (\n      isBoolean(value) ||\n      isObject(value) ||\n      isFunction(value)\n    )\n  ) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value));\n  }\n}\n\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  return (value === true) ? name : value\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false];\n\n// see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener\n};\n\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\nfunction eventExpression(node, { name }, value) {\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n\n    return textNode\n  }\n\n  return target\n};\n\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nconst expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n\n  // API methods\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope);\n\n    // IO() DOM updates\n    apply(this, this.value);\n\n    return this\n  },\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this\n  },\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n\n    return this\n  }\n};\n\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value)\n}\n\nfunction create$4(node, data) {\n  return {\n    ...Expression,\n    ...data,\n    node: data.type === TEXT ?\n      getTextNode(node, data.childNodeIndex) :\n      node\n  }\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return {\n      ...acc,\n      [method]: (scope) => {\n        return collection.map(item => item[method](scope)) && context\n      }\n    }\n  }, {})\n}\n\nfunction create$3(node, { expressions }) {\n  return {\n    ...flattenCollectionMethods(\n      expressions.map(expression => create$4(node, expression)),\n      ['mount', 'update', 'unmount']\n    )\n  }\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope\n\n  const expressions = attributes.map(attr => ({\n    ...attr,\n    value: attr.evaluate(scope)\n  }));\n\n  return Object.assign(\n    Object.create(parentScope || null),\n    evaluateAttributeExpressions(expressions)\n  )\n}\n\n// this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\nconst getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n  // template: null,\n\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope)\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find(({id}) => id === this.name) : false;\n    const {parentNode} = this.node;\n    const realParent = getRealParent(scope, parentScope);\n\n    this.template = templateData && create(\n      templateData.html,\n      templateData.bindings\n    ).createDOM(parentNode);\n\n    if (this.template) {\n      cleanNode(this.node);\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = Array.from(this.node.childNodes);\n    }\n\n    moveSlotInnerContent(this.node);\n    removeChild(this.node);\n\n    return this\n  },\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this\n  }\n};\n\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method \u00AF\\_(\u30C4)_/\u00AF\n */\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n\n  if (!child) return\n\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\nfunction createSlot(node, { name, attributes }) {\n  return {\n    ...SlotBinding,\n    attributes,\n    node,\n    name\n  }\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\nfunction getTag(component, slots = [], attributes = []) {\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({slots, attributes})\n  }\n\n  // otherwise we return a template chunk\n  return create(slotsToMarkup(slots), [\n    ...slotBindings(slots), {\n      // the attributes should be registered as binding\n      // if we fallback to a normal template chunk\n      expressions: attributes.map(attr => {\n        return {\n          type: ATTRIBUTE,\n          ...attr\n        }\n      })\n    }\n  ])\n}\n\n\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\nfunction slotBindings(slots) {\n  return slots.reduce((acc, {bindings}) => acc.concat(bindings), [])\n}\n\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html\n  }, '')\n}\n\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n\n  mount(scope) {\n    return this.update(scope)\n  },\n  update(scope, parentScope) {\n    const name = this.evaluate(scope);\n\n    // simple update\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true);\n\n      // mount the new tag\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this\n  },\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this\n  }\n};\n\nfunction create$2(node, {evaluate, getComponent, slots, attributes}) {\n  return {\n    ...TagBinding,\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  }\n}\n\nconst bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? {\n    ...e,\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  } : e)\n}\n\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\nfunction create$1(root, binding, templateTagOffset) {\n  const { selector, type, redundantAttribute, expressions } = binding;\n  // find the node to apply the bindings\n  const node = selector ? root.querySelector(selector) : root;\n\n  // remove eventually additional attributes created only to select this node\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || [];\n\n  // init the binding\n  return (bindings[type] || bindings[SIMPLE])(\n    node,\n    {\n      ...binding,\n      expressions: templateTagOffset && !selector ?\n        fixTextExpressionsOffset(bindingExpressions, templateTagOffset) :\n        bindingExpressions\n    }\n  )\n}\n\n// in this case a simple innerHTML is enough\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content\n}\n\n// for svg nodes we need a bit more work\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(\n    new window.DOMParser()\n      .parseFromString(\n        `<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`,\n        'application/xml'\n      )\n      .documentElement,\n    true\n  );\n\n  return svgNode\n}\n\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root)\n\n  return createHTMLTree(html, root)\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\nfunction injectDOM(el, dom) {\n  switch (true) {\n  case isSvg(el):\n    moveChildren(dom, el);\n    break\n  case isTemplate(el):\n    el.parentNode.replaceChild(dom, el);\n    break\n  default:\n    el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ?\n    createDOMTree(el, html) :\n    html)\n}\n\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n\n  return Math.max(\n    siblings.indexOf(el),\n    siblings.indexOf(meta.head) + 1,\n    0\n  )\n}\n\n/**\n * Template Chunk model\n * @type {Object}\n */\nconst TemplateChunk = {\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();\n\n    return this\n  },\n\n  // API methods\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta = {}) {\n    if (!el) panic('Please provide DOM node to mount properly your template');\n\n    if (this.el) this.unmount(scope);\n\n    // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n    const {fragment, children, avoidDOMInjection} = meta;\n    // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n    const {parentNode} = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null;\n\n    // create the DOM if it wasn't created before\n    this.createDOM(el);\n\n    // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n    const cloneNode = fragment || this.dom.cloneNode(true);\n\n    // store root node\n    // notice that for template tags the root note will be the parent tag\n    this.el = isTemplateTag ? parentNode : el;\n\n    // create the children array only for the <template> fragments\n    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null;\n\n    // inject the DOM into the el only if a fragment is available\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode);\n\n    // create the bindings\n    this.bindings = this.bindingsData.map(binding => create$1(\n      this.el,\n      binding,\n      templateTagOffset\n    ));\n    this.bindings.forEach(b => b.mount(scope, parentScope));\n\n    // store the template meta properties\n    this.meta = meta;\n\n    return this\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n\n    return this\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot = false) {\n    const el = this.el;\n\n    if (!el) {\n      return this\n    }\n\n    this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n    switch (true) {\n    // pure components should handle the DOM unmount updates by themselves\n    // for mustRemoveRoot === null don't touch the DOM\n    case (el[IS_PURE_SYMBOL] || mustRemoveRoot === null):\n      break\n\n    // if children are declared, clear them\n    // applicable for <template> and <slot/> bindings\n    case Array.isArray(this.children):\n      clearChildren(this.children);\n      break\n\n    // clean the node children only\n    case !mustRemoveRoot:\n      cleanNode(el);\n      break\n\n    // remove the root node only if the mustRemoveRoot is truly\n    case !!mustRemoveRoot:\n      removeChild(el);\n      break\n    }\n\n    this.el = null;\n\n    return this\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return {\n      ...this,\n      meta: {},\n      el: null\n    }\n  }\n};\n\n\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\nfunction create(html, bindings = []) {\n  return {\n    ...TemplateChunk,\n    html,\n    bindingsData: bindings\n  }\n}\n\nexport { create$1 as createBinding, create$4 as createExpression, create as template };\n", "/* Riot WIP, @license MIT */\nimport { callOrAssign, camelToDashCase } from '@riotjs/util';\nimport { createComponentFromWrapper } from './create-component-from-wrapper.js';\n\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\nfunction createChildrenComponentsObject(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref) => {\n    let [key, value] = _ref;\n    acc[camelToDashCase(key)] = createComponentFromWrapper(value);\n    return acc;\n  }, {});\n}\n\nexport { createChildrenComponentsObject };\n", "/* Riot WIP, @license MIT */\nimport { template, expressionTypes, bindingTypes } from '@riotjs/dom-bindings';\nimport { COMPONENTS_IMPLEMENTATION_MAP } from '@riotjs/util';\nimport { createChildrenComponentsObject } from './create-children-components-object.js';\nimport { memoizedCreateComponentFromWrapper } from './create-component-from-wrapper.js';\n\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {TemplateChunk} template chunk object\n */\n\nfunction componentTemplateFactory(template$1, componentWrapper) {\n  const components = createChildrenComponentsObject(componentWrapper.exports ? componentWrapper.exports.components : {});\n  return template$1(template, expressionTypes, bindingTypes, name => {\n    // improve support for recursive components\n    if (name === componentWrapper.name) return memoizedCreateComponentFromWrapper(componentWrapper); // return the registered components\n\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP.get(name);\n  });\n}\n\nexport { componentTemplateFactory };\n", "/* Riot WIP, @license MIT */\nimport { DOM_COMPONENT_INSTANCE_PROPERTY } from '@riotjs/util';\n\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\nconst bindDOMNodeToComponentInstance = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY] = component;\n\nexport { bindDOMNodeToComponentInstance };\n", "/* Riot WIP, @license MIT */\nimport { MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY } from '@riotjs/util';\n\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n\nexport { createCoreAPIMethods };\n", "/* Riot WIP, @license MIT */\nimport { panic, defineDefaults, MOUNT_METHOD_KEY, defineProperty, IS_PURE_SYMBOL } from '@riotjs/util';\nimport { PURE_COMPONENT_API } from './pure-component-api.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\n\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args; // mark this node as pure element\n\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentInstance(element, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n\nexport { createPureComponent };\n", "/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nexport default function domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}", "import domToArray from 'bianco.dom-to-array'\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nexport default function $(selector, scope) {\n  return domToArray(typeof selector === 'string' ?\n    (scope || document).querySelectorAll(selector) :\n    selector\n  )\n}\n", "/* Riot WIP, @license MIT */\nimport $ from 'bianco.query';\n\nconst COMPONENT_DOM_SELECTORS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\n\nexport { COMPONENT_DOM_SELECTORS };\n", "/* Riot WIP, @license MIT */\nimport { SHOULD_UPDATE_KEY, noop, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, ON_BEFORE_UPDATE_KEY, ON_UPDATED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UNMOUNTED_KEY } from '@riotjs/util';\n\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\n\nexport { COMPONENT_LIFECYCLE_METHODS };\n", "import domToArray from 'bianco.dom-to-array'\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\nconst normalize = values => values.length === 1 ? values[0] : values\n\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)))\n  }))\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\nexport function set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : { [name]: value }\n  const props = Object.keys(attrs)\n\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]))\n  })\n  return els\n}\n\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\nexport function get(els, name) {\n  return parseNodes(els, name, 'getAttribute')\n}\n\n/**\n * Remove any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to remove\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { remove } from 'bianco.attr'\n *\n * remove(img, 'width') // remove the width attribute\n *\n * // or also\n * remove(img, ['width', 'height']) // remove the width and the height attribute\n *\n * // or also\n * remove([img1, img2], ['width', 'height']) // remove the width and the height attribute from both images\n */\nexport function remove(els, name) {\n  return parseNodes(els, name, 'removeAttribute')\n}\n\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to detect\n * @returns { boolean|Array } true or false or an array of boolean values\n * @example\n *\n * import { has } from 'bianco.attr'\n *\n * has(img, 'width') // false\n *\n * // or also\n * has(img, ['width', 'height']) // => [false, false]\n *\n * // or also\n * has([img1, img2], ['width', 'height']) // => [[false, false], [false, false]]\n */\nexport function has(els, name) {\n  return parseNodes(els, name, 'hasAttribute')\n}\n\nexport default {\n  get,\n  set,\n  remove,\n  has\n}", "/* Riot WIP, @license MIT */\nimport $ from 'bianco.query';\nimport { set } from 'bianco.attr';\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nconst cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\nexport { CSS_BY_NAME, STYLE_NODE_SELECTOR, cssManager as default };\n", "/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nexport default function curry(fn, ...acc) {\n  return (...args) => {\n    args = [...acc, ...args]\n\n    return args.length < fn.length ?\n      curry(fn, ...args) :\n      fn(...args)\n  }\n}", "/* Riot WIP, @license MIT */\nimport { IS_DIRECTIVE } from '@riotjs/util';\nimport { get } from 'bianco.attr';\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nexport { getName };\n", "/* Riot WIP, @license MIT */\nimport { IS_DIRECTIVE } from '@riotjs/util';\nimport { getName } from '../utils/dom.js';\nimport { set } from 'bianco.attr';\n\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n\nexport { addCssHook };\n", "/* Riot WIP, @license MIT */\nimport { callOrAssign } from '@riotjs/util';\n\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state given to the `update` call\n * @returns {Object} new object state\n */\n\nfunction computeComponentState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n\nexport { computeComponentState };\n", "/* Riot WIP, @license MIT */\nimport { DOMattributesToObject, callOrAssign } from '@riotjs/util';\n\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction computeInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n\nexport { computeInitialProps };\n", "/* Riot WIP, @license MIT */\nimport { createCoreAPIMethods } from './create-core-api-methods.js';\nimport { createExpression } from '@riotjs/dom-bindings';\n\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => createExpression(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n\nexport { createAttributeBindings };\n", "/* Riot WIP, @license MIT */\nimport { PLUGINS_SET } from '@riotjs/util';\n\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET].reduce((c, fn) => fn(c) || c, component);\n}\n\nexport { runPlugins };\n", "/* Riot WIP, @license MIT */\nimport { autobindMethods, defineProperties, isObject, defineProperty, IS_PURE_SYMBOL, PARENT_KEY_SYMBOL, ATTRIBUTES_KEY_SYMBOL, PROPS_KEY, evaluateAttributeExpressions, STATE_KEY, TEMPLATE_KEY_SYMBOL, ROOT_KEY, SLOTS_KEY, ON_BEFORE_MOUNT_KEY, ON_MOUNTED_KEY, SHOULD_UPDATE_KEY, ON_BEFORE_UPDATE_KEY, IS_COMPONENT_UPDATING, ON_UPDATED_KEY, ON_BEFORE_UNMOUNT_KEY, ON_UNMOUNTED_KEY, isFunction } from '@riotjs/util';\nimport { addCssHook } from './add-css-hook.js';\nimport { bindDOMNodeToComponentInstance } from './bind-dom-node-to-component-instance.js';\nimport { computeComponentState } from './compute-component-state.js';\nimport { computeInitialProps } from './compute-initial-props.js';\nimport { createAttributeBindings } from './create-attribute-bindings.js';\nimport { runPlugins } from './run-plugins.js';\n\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\nfunction manageComponentLifecycle(component, _ref) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref;\n  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      // any element mounted passing through this function can't be a pure component\n      defineProperty(element, IS_PURE_SYMBOL, false);\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, computeInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentInstance(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeComponentState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]); // avoiding recursive updates\n      // see also https://github.com/riot/riot/issues/2895\n\n      if (!this[IS_COMPONENT_UPDATING]) {\n        this[IS_COMPONENT_UPDATING] = true;\n        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      }\n\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[IS_COMPONENT_UPDATING] = false;\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n\nexport { manageComponentLifecycle };\n", "/* Riot WIP, @license MIT */\nimport { defineProperties, defineDefaults, PROPS_KEY, STATE_KEY, SLOTS_KEY, ROOT_KEY } from '@riotjs/util';\nimport { COMPONENT_DOM_SELECTORS } from './component-dom-selectors.js';\nimport { COMPONENT_LIFECYCLE_METHODS } from './component-lifecycle-methods.js';\nimport cssManager from './css-manager.js';\nimport curry from 'curri';\nimport { manageComponentLifecycle } from './manage-component-lifecycle.js';\n\n/**\n * Component definition function\n * @param   {Object} implementation - the component implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction instantiateComponent(_ref) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(manageComponentLifecycle)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [PROPS_KEY]: {},\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_DOM_SELECTORS, {\n    name,\n    css,\n    template\n  })));\n}\n\nexport { instantiateComponent };\n", "/* Riot WIP, @license MIT */\nimport { IS_PURE_SYMBOL, callOrAssign, memoize } from '@riotjs/util';\nimport { MOCKED_TEMPLATE_INTERFACE } from './mocked-template-interface.js';\nimport { componentTemplateFactory } from './component-template-factory.js';\nimport { createPureComponent } from './create-pure-component.js';\nimport { instantiateComponent } from './instantiate-component.js';\n\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\n\nfunction createComponentFromWrapper(componentWrapper) {\n  const {\n    css,\n    template,\n    exports,\n    name\n  } = componentWrapper;\n  const templateFn = template ? componentTemplateFactory(template, componentWrapper) : MOCKED_TEMPLATE_INTERFACE;\n  return _ref => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = instantiateComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components created via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\n\nconst memoizedCreateComponentFromWrapper = memoize(createComponentFromWrapper);\n\nexport { createComponentFromWrapper, memoizedCreateComponentFromWrapper };\n", "/* Riot WIP, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP, panic } from '@riotjs/util';\nimport { createComponentFromWrapper } from '../core/create-component-from-wrapper.js';\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponentFromWrapper({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n\nexport { register };\n", "/* Riot WIP, @license MIT */\nimport { COMPONENTS_IMPLEMENTATION_MAP, panic } from '@riotjs/util';\nimport { getName } from '../utils/dom.js';\n\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @param   {Array} slots - component slots\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName, slots) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP.get(name)({\n    props: initialProps,\n    slots\n  });\n  return component.mount(element);\n}\n\nexport { mountComponent };\n", "/* Riot WIP, @license MIT */\nimport $ from 'bianco.query';\nimport { mountComponent } from '../core/mount-component.js';\n\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n\nexport { mount };\n", "import { register, mount } from 'riot';\n\nconst start = (element, position = 'beforeend') => {\n  const selector = element.dataset.target;\n  const where = selector ? document.querySelector(selector) : document.body;\n  const what = element.text.trim().replace(/\\n\\s+/gm, '');\n  where.insertAdjacentHTML(position, what);\n};\n\nvar component = {\n  'css': `simple-component-riot,[is=\"simple-component-riot\"]{ display: block; padding: 2em; background: lightgreen; color: var(--shade2); text-align: center; cursor: pointer; } simple-component-riot.active,[is=\"simple-component-riot\"].active{ background: var(--shade1); color: var(--shade0); } simple-component-riot.active > *,[is=\"simple-component-riot\"].active > *{ color: inherit; } simple-component-riot h1,[is=\"simple-component-riot\"] h1{ color: var(--shade1); } simple-component-riot p,[is=\"simple-component-riot\"] p{ font-size: 0.8em; text-transform: uppercase; }`,\n  'exports': {\n    onBeforeMount() {\n      // initial state\n      this.state = {\n        count: 0,\n        active: false\n      };\n    },\n\n    onMounted() {\n      // the only option to move the children where we want\n      this.$('.children').appendChild(this.root.children[0]);\n    },\n\n    handleClick() {\n      const {\n        count,\n        active\n      } = this.state;\n      this.update({\n        count: count + 1,\n        active: !active\n      });\n    }\n\n  },\n  'template': function (template, expressionTypes, bindingTypes, getComponent) {\n    return template('<h3 expr0=\"expr0\"> </h3><pre expr1=\"expr1\"> </pre><div class=\"children\"></div>', [{\n      'expressions': [{\n        'type': expressionTypes.ATTRIBUTE,\n        'name': 'class',\n        'evaluate': function (scope) {\n          return scope.state.active ? 'active' : null;\n        }\n      }, {\n        'type': expressionTypes.EVENT,\n        'name': 'onclick',\n        'evaluate': function (scope) {\n          return scope.handleClick;\n        }\n      }]\n    }, {\n      'redundantAttribute': 'expr0',\n      'selector': '[expr0]',\n      'expressions': [{\n        'type': expressionTypes.TEXT,\n        'childNodeIndex': 0,\n        'evaluate': function (scope) {\n          return scope.props.title;\n        }\n      }]\n    }, {\n      'redundantAttribute': 'expr1',\n      'selector': '[expr1]',\n      'expressions': [{\n        'type': expressionTypes.TEXT,\n        'childNodeIndex': 0,\n        'evaluate': function (scope) {\n          return ['Clicked: ', scope.state.count, ' times'].join('');\n        }\n      }]\n    }]);\n  },\n  'name': 'simple-component-riot'\n};\n\nregister('simple-component-riot', component);\nstart(document.currentScript);\nmount('simple-component-riot');\n"],
  "mappings": "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",
  "names": ["checkType", "element", "type", "isFunction", "value", "checkType", "isObject", "value", "isNil", "COMPONENTS_IMPLEMENTATION_MAP", "DOM_COMPONENT_INSTANCE_PROPERTY", "PLUGINS_SET", "IS_DIRECTIVE", "MOUNT_METHOD_KEY", "UPDATE_METHOD_KEY", "UNMOUNT_METHOD_KEY", "SHOULD_UPDATE_KEY", "ON_BEFORE_MOUNT_KEY", "ON_MOUNTED_KEY", "ON_BEFORE_UPDATE_KEY", "ON_UPDATED_KEY", "ON_BEFORE_UNMOUNT_KEY", "ON_UNMOUNTED_KEY", "PROPS_KEY", "STATE_KEY", "SLOTS_KEY", "ROOT_KEY", "IS_PURE_SYMBOL", "IS_COMPONENT_UPDATING", "PARENT_KEY_SYMBOL", "ATTRIBUTES_KEY_SYMBOL", "TEMPLATE_KEY_SYMBOL", "camelToDashCase", "string", "dashToCamelCase", "_", "c", "DOMattributesToObject", "element", "acc", "attribute", "dashToCamelCase", "noop", "autobindMethods", "source", "methods", "method", "callOrAssign", "isFunction", "panic", "message", "memoize", "fn", "cache", "cached", "val", "evaluateAttributeExpressions", "attributes", "acc", "attribute", "value", "type", "dashToCamelCase", "defineProperty", "source", "key", "value", "options", "defineProperties", "properties", "defineDefaults", "defaults", "PURE_COMPONENT_API", "MOUNT_METHOD_KEY", "noop", "UPDATE_METHOD_KEY", "UNMOUNT_METHOD_KEY", "MOCKED_TEMPLATE_INTERFACE", "PURE_COMPONENT_API", "noop", "dashToCamelCase", "string", "_", "c", "moveChildren", "source", "target", "cleanNode", "node", "clearChildren", "children", "i", "removeChild", "insertBefore", "newNode", "refNode", "replaceChild", "replaced", "DOM_COMPONENT_INSTANCE_PROPERTY", "IS_PURE_SYMBOL", "IS_COMPONENT_UPDATING", "PARENT_KEY_SYMBOL", "ATTRIBUTES_KEY_SYMBOL", "TEMPLATE_KEY_SYMBOL", "binding_types_default", "expression_types_default", "defineProperty", "source", "key", "value", "options", "checkType", "element", "type", "isSvg", "el", "owner", "isTemplate", "isFunction", "value", "isBoolean", "isObject", "isNil", "panic", "message", "memoize", "fn", "cache", "cached", "val", "evaluateAttributeExpressions", "attributes", "acc", "attribute", "value", "type", "dashToCamelCase", "HEAD_SYMBOL", "TAIL_SYMBOL", "createHeadTailPlaceholders", "head", "tail", "createTemplateMeta", "componentTemplate", "fragment", "udomdiff", "a", "b", "get", "before", "bLength", "aEnd", "bEnd", "aStart", "bStart", "map", "node", "insertBefore", "removeChild", "i", "index", "sequence", "replaceChild", "UNMOUNT_SCOPE", "EachBinding", "scope", "parentScope", "placeholder", "nodes", "childrenMap", "collection", "items", "newChildrenMap", "batches", "futureNodes", "createPatch", "patch", "fn", "redundant", "item", "info", "element", "template", "context", "mustFilterItem", "condition", "extendScope", "itemName", "indexName", "defineProperty", "binding", "getKey", "root", "isTemplateTag", "key", "oldItem", "mustMount", "el", "meta", "create$6", "evaluate", "isTemplate", "IfBinding", "value", "mustUnmount", "mount", "pristine", "create$5", "ElementProto", "isNativeHtmlProperty", "memoize", "name", "setAllAttributes", "attributes", "attributeExpression", "removeAllAttributes", "newAttributes", "oldAttributes", "newKeys", "attribute", "canRenderAttribute", "shouldRemoveAttribute", "oldValue", "isBoolean", "isObject", "isFunction", "normalizeValue", "RE_EVENTS_PREFIX", "getCallbackAndOptions", "EventListener", "event", "ListenersWeakMap", "createListener", "listener", "eventExpression", "normalizedEventName", "eventListener", "callback", "options", "handler", "mustRemoveEvent", "mustAddEvent", "normalizeStringValue", "isNil", "getTextNode", "childNodeIndex", "target", "textNode", "textExpression", "data", "valueExpression", "expression", "expressions", "Expression", "apply", "create$4", "flattenCollectionMethods", "methods", "acc", "method", "create$3", "extendParentScope", "attr", "evaluateAttributeExpressions", "getRealParent", "PARENT_KEY_SYMBOL", "SlotBinding", "templateData", "id", "parentNode", "realParent", "create", "cleanNode", "moveSlotInnerContent", "mustRemoveRoot", "slot", "child", "createSlot", "getTag", "component", "slots", "slotsToMarkup", "slotBindings", "bindings", "TagBinding", "keepRootTag", "create$2", "getComponent", "fixTextExpressionsOffset", "textExpressionsOffset", "e", "create$1", "templateTagOffset", "selector", "type", "redundantAttribute", "bindingExpressions", "createHTMLTree", "html", "createSVGTree", "container", "createDOMTree", "isSvg", "injectDOM", "dom", "moveChildren", "createTemplateDOM", "getTemplateTagOffset", "siblings", "TemplateChunk", "panic", "children", "avoidDOMInjection", "cloneNode", "IS_PURE_SYMBOL", "clearChildren", "createChildrenComponentsObject", "components", "callOrAssign", "acc", "_ref", "key", "value", "camelToDashCase", "createComponentFromWrapper", "componentTemplateFactory", "template$1", "componentWrapper", "components", "createChildrenComponentsObject", "create", "expression_types_default", "binding_types_default", "name", "memoizedCreateComponentFromWrapper", "COMPONENTS_IMPLEMENTATION_MAP", "bindDOMNodeToComponentInstance", "node", "component", "DOM_COMPONENT_INSTANCE_PROPERTY", "createCoreAPIMethods", "mapFunction", "MOUNT_METHOD_KEY", "UPDATE_METHOD_KEY", "UNMOUNT_METHOD_KEY", "acc", "method", "createPureComponent", "pureFactoryFunction", "_ref", "slots", "attributes", "props", "css", "template", "panic", "component", "defineDefaults", "PURE_COMPONENT_API", "createCoreAPIMethods", "method", "_len", "args", "_key", "MOUNT_METHOD_KEY", "element", "defineProperty", "IS_PURE_SYMBOL", "bindDOMNodeToComponentInstance", "domToArray", "els", "$", "selector", "scope", "domToArray", "COMPONENT_DOM_SELECTORS", "selector", "$", "COMPONENT_LIFECYCLE_METHODS", "SHOULD_UPDATE_KEY", "noop", "ON_BEFORE_MOUNT_KEY", "ON_MOUNTED_KEY", "ON_BEFORE_UPDATE_KEY", "ON_UPDATED_KEY", "ON_BEFORE_UNMOUNT_KEY", "ON_UNMOUNTED_KEY", "normalize", "values", "parseNodes", "els", "name", "method", "names", "domToArray", "el", "n", "set", "value", "attrs", "props", "prop", "get", "CSS_BY_NAME", "STYLE_NODE_SELECTOR", "getStyleNode", "style", "$", "set", "cssManager", "name", "css", "curry", "fn", "acc", "args", "getName", "element", "get", "IS_DIRECTIVE", "addCssHook", "element", "name", "getName", "set", "IS_DIRECTIVE", "computeComponentState", "oldState", "newState", "callOrAssign", "computeInitialProps", "element", "initialProps", "DOMattributesToObject", "callOrAssign", "createAttributeBindings", "node", "attributes", "expressions", "a", "create$4", "binding", "createCoreAPIMethods", "method", "scope", "e", "runPlugins", "component", "PLUGINS_SET", "c", "fn", "manageComponentLifecycle", "component", "_ref", "slots", "attributes", "props", "autobindMethods", "runPlugins", "defineProperties", "isObject", "element", "state", "parentScope", "defineProperty", "IS_PURE_SYMBOL", "PARENT_KEY_SYMBOL", "ATTRIBUTES_KEY_SYMBOL", "createAttributeBindings", "PROPS_KEY", "computeInitialProps", "evaluateAttributeExpressions", "STATE_KEY", "computeComponentState", "TEMPLATE_KEY_SYMBOL", "bindDOMNodeToComponentInstance", "addCssHook", "ROOT_KEY", "SLOTS_KEY", "ON_BEFORE_MOUNT_KEY", "ON_MOUNTED_KEY", "newProps", "SHOULD_UPDATE_KEY", "ON_BEFORE_UPDATE_KEY", "IS_COMPONENT_UPDATING", "ON_UPDATED_KEY", "preserveRoot", "ON_BEFORE_UNMOUNT_KEY", "ON_UNMOUNTED_KEY", "prop", "isFunction", "instantiateComponent", "_ref", "css", "template", "componentAPI", "name", "cssManager", "curry", "manageComponentLifecycle", "defineProperties", "defineDefaults", "COMPONENT_LIFECYCLE_METHODS", "PROPS_KEY", "STATE_KEY", "SLOTS_KEY", "ROOT_KEY", "COMPONENT_DOM_SELECTORS", "createComponentFromWrapper", "componentWrapper", "css", "template", "exports", "name", "templateFn", "componentTemplateFactory", "MOCKED_TEMPLATE_INTERFACE", "_ref", "slots", "attributes", "props", "IS_PURE_SYMBOL", "createPureComponent", "componentAPI", "callOrAssign", "component", "instantiateComponent", "element", "parentScope", "state", "preserveRoot", "memoizedCreateComponentFromWrapper", "memoize", "register", "name", "_ref", "css", "template", "exports", "COMPONENTS_IMPLEMENTATION_MAP", "panic", "createComponentFromWrapper", "mountComponent", "element", "initialProps", "componentName", "slots", "name", "getName", "COMPONENTS_IMPLEMENTATION_MAP", "panic", "mount", "selector", "initialProps", "name", "$", "element", "mountComponent", "start", "element", "position", "selector", "where", "what", "component", "count", "active", "template", "expressionTypes", "bindingTypes", "getComponent", "scope", "register", "mount"]
}
