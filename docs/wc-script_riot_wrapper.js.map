{
  "version": 3,
  "sources": ["../node_modules/riot/riot.esm.js", "../src/js/wc-script_riot_wrapper.js"],
  "sourcesContent": ["/* Riot v5.4.5, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method \u00AF\\_(\u30C4)_/\u00AF\n */\n// Ignore this helper because it's needed only for svg tags\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction cleanNode(node) {\n  clearChildren(node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\nfunction clearChildren(children) {\n  Array.from(children).forEach(removeChild);\n}\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\n\nconst removeChild = node => node && node.parentNode && node.parentNode.removeChild(node);\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\n\nconst insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\n\nconst replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);\n\n// Riot.js constants that can be used accross more modules\nconst COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol('riot-component'),\n      PLUGINS_SET$1 = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      MOUNT_METHOD_KEY = 'mount',\n      UPDATE_METHOD_KEY = 'update',\n      UNMOUNT_METHOD_KEY = 'unmount',\n      SHOULD_UPDATE_KEY = 'shouldUpdate',\n      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n      ON_MOUNTED_KEY = 'onMounted',\n      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n      ON_UPDATED_KEY = 'onUpdated',\n      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n      ON_UNMOUNTED_KEY = 'onUnmounted',\n      PROPS_KEY = 'props',\n      STATE_KEY = 'state',\n      SLOTS_KEY = 'slots',\n      ROOT_KEY = 'root',\n      IS_PURE_SYMBOL = Symbol('pure'),\n      IS_COMPONENT_UPDATING = Symbol('is_updating'),\n      PARENT_KEY_SYMBOL = Symbol('parent'),\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  PLUGINS_SET: PLUGINS_SET$1,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,\n  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,\n  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,\n  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,\n  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,\n  ON_MOUNTED_KEY: ON_MOUNTED_KEY,\n  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,\n  ON_UPDATED_KEY: ON_UPDATED_KEY,\n  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,\n  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,\n  PROPS_KEY: PROPS_KEY,\n  STATE_KEY: STATE_KEY,\n  SLOTS_KEY: SLOTS_KEY,\n  ROOT_KEY: ROOT_KEY,\n  IS_PURE_SYMBOL: IS_PURE_SYMBOL,\n  IS_COMPONENT_UPDATING: IS_COMPONENT_UPDATING,\n  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n\nconst HEAD_SYMBOL = Symbol('head');\nconst TAIL_SYMBOL = Symbol('tail');\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: TextNode, tail: TextNode}}\n */\n\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n  return {\n    head,\n    tail\n  };\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\n\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const {\n    head,\n    tail\n  } = createHeadTailPlaceholders();\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail]\n  };\n}\n\n/**\n * Get the current <template> fragment children located in between the head and tail comments\n * @param {Comment} head - head comment node\n * @param {Comment} tail - tail comment node\n * @return {Array[]} children list of the nodes found in this template fragment\n */\n\nfunction getFragmentChildren(_ref) {\n  let {\n    head,\n    tail\n  } = _ref;\n  const nodes = walkNodes([head], head.nextSibling, n => n === tail, false);\n  nodes.push(tail);\n  return nodes;\n}\n/**\n * Recursive function to walk all the <template> children nodes\n * @param {Array[]} children - children nodes collection\n * @param {ChildNode} node - current node\n * @param {Function} check - exit function check\n * @param {boolean} isFilterActive - filter flag to skip nodes managed by other bindings\n * @returns {Array[]} children list of the nodes found in this template fragment\n */\n\nfunction walkNodes(children, node, check, isFilterActive) {\n  const {\n    nextSibling\n  } = node; // filter tail and head nodes together with all the nodes in between\n  // this is needed only to fix a really ugly edge case https://github.com/riot/riot/issues/2892\n\n  if (!isFilterActive && !node[HEAD_SYMBOL] && !node[TAIL_SYMBOL]) {\n    children.push(node);\n  }\n\n  if (!nextSibling || check(node)) return children;\n  return walkNodes(children, nextSibling, check, // activate the filters to skip nodes between <template> fragments that will be managed by other bindings\n  isFilterActive && !node[TAIL_SYMBOL] || nextSibling[HEAD_SYMBOL]);\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template';\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\n\nfunction isBoolean(value) {\n  return checkType(value, 'boolean');\n}\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\n\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object;\n}\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\n\nvar udomdiff = ((a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;\n\n      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);\n    } // remove head or tail: fast path\n    else if (bEnd === bStart) {\n        while (aStart < aEnd) {\n          // remove the node only if it's unknown or not live\n          if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));\n          aStart++;\n        }\n      } // same node: fast path\n      else if (a[aStart] === b[bStart]) {\n          aStart++;\n          bStart++;\n        } // same tail: fast path\n        else if (a[aEnd - 1] === b[bEnd - 1]) {\n            aEnd--;\n            bEnd--;\n          } // The once here single last swap \"fast path\" has been removed in v1.1.0\n          // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n          // reverse swap: also fast path\n          else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n              // this is a \"shrink\" operation that could happen in these cases:\n              // [1, 2, 3, 4, 5]\n              // [1, 4, 3, 2, 5]\n              // or asymmetric too\n              // [1, 2, 3, 4, 5]\n              // [1, 2, 3, 5, 6, 4]\n              const node = get(a[--aEnd], -1).nextSibling;\n              insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n              insertBefore(get(b[--bEnd], 1), node); // mark the future index as identical (yeah, it's dirty, but cheap \uD83D\uDC4D)\n              // The main reason to do this, is that when a[aEnd] will be reached,\n              // the loop will likely be on the fast path, as identical to b[bEnd].\n              // In the best case scenario, the next loop will skip the tail,\n              // but in the worst one, this node will be considered as already\n              // processed, bailing out pretty quickly from the map index check\n\n              a[aEnd] = b[bEnd];\n            } // map based fallback, \"slow\" path\n            else {\n                // the map requires an O(bEnd - bStart) operation once\n                // to store all future nodes indexes for later purposes.\n                // In the worst case scenario, this is a full O(N) cost,\n                // and such scenario happens at least when all nodes are different,\n                // but also if both first and last items of the lists are different\n                if (!map) {\n                  map = new Map();\n                  let i = bStart;\n\n                  while (i < bEnd) map.set(b[i], i++);\n                } // if it's a future node, hence it needs some handling\n\n\n                if (map.has(a[aStart])) {\n                  // grab the index of such node, 'cause it might have been processed\n                  const index = map.get(a[aStart]); // if it's not already processed, look on demand for the next LCS\n\n                  if (bStart < index && index < bEnd) {\n                    let i = aStart; // counts the amount of nodes that are the same in the future\n\n                    let sequence = 1;\n\n                    while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++; // effort decision here: if the sequence is longer than replaces\n                    // needed to reach such sequence, which would brings again this loop\n                    // to the fast path, prepend the difference before a sequence,\n                    // and move only the future list index forward, so that aStart\n                    // and bStart will be aligned again, hence on the fast path.\n                    // An example considering aStart and bStart are both 0:\n                    // a: [1, 2, 3, 4]\n                    // b: [7, 1, 2, 3, 6]\n                    // this would place 7 before 1 and, from that time on, 1, 2, and 3\n                    // will be processed at zero cost\n\n\n                    if (sequence > index - bStart) {\n                      const node = get(a[aStart], 0);\n\n                      while (bStart < index) insertBefore(get(b[bStart++], 1), node);\n                    } // if the effort wasn't good enough, fallback to a replace,\n                    // moving both source and target indexes forward, hoping that some\n                    // similar node will be found later on, to go back to the fast path\n                    else {\n                        replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));\n                      }\n                  } // otherwise move the source forward, 'cause there's nothing to do\n                  else aStart++;\n                } // this node has no meaning in the future list, so it's more than safe\n                // to remove it, and check the next live node out instead, meaning\n                // that only the live list index should be forwarded\n                else removeChild(get(a[aStart++], -1));\n              }\n  }\n\n  return b;\n});\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : []; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder); // trigger the mounts and the updates\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes; // make sure that the loop edge nodes are marked\n\n    markEdgeNodes(this.nodes);\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n\n};\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const {\n          template,\n          nodes,\n          context\n        } = element; // remove the last node (notice <template> tags might have more children nodes)\n\n        nodes.pop(); // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n\n        if (nodes.length === 0) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item;\n  };\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? Boolean(condition(context)) === false : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  scope[itemName] = item;\n  if (indexName) scope[indexName] = index;\n  return scope;\n}\n/**\n * Mark the first and last nodes in order to ignore them in case we need to retrieve the <template> fragment nodes\n * @param {Array[]} nodes - each binding nodes list\n * @returns {undefined} void function\n */\n\n\nfunction markEdgeNodes(nodes) {\n  const first = nodes[0];\n  const last = nodes[nodes.length - 1];\n  if (first) first[HEAD_SYMBOL] = true;\n  if (last) last[TAIL_SYMBOL] = true;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EeachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      nodes.push(...(mustMount ? meta.children : getFragmentChildren(meta)));\n    } else {\n      nodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key);\n    futureNodes.push(...nodes); // update the children map\n\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create$6(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n\n/**\n * Binding responsible for the `if` directive\n */\n\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n\n};\nfunction create$5(node, _ref) {\n  let {\n    evaluate,\n    template\n  } = _ref;\n  const placeholder = document.createTextNode('');\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\n\nfunction memoize(fn) {\n  const cache = new Map();\n\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n\n  cached.cache = cache;\n  return cached;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach(_ref => {\n    let [name, value] = _ref;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\n\n\nfunction canRenderAttribute(value) {\n  return value === true || ['string', 'number'].includes(typeof value);\n}\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\n\n\nfunction shouldRemoveAttribute(value) {\n  return isNil(value) || value === false || value === '';\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref2, value, oldValue) {\n  let {\n    name\n  } = _ref2;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    } // is the value still truthy?\n\n\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value));\n  }\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  if (value === true) return name;\n  return value;\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n\n\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener;\n};\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\n\n\nfunction eventExpression(node, _ref, value) {\n  let {\n    name\n  } = _ref;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {HTMLTextNode} the text node to update\n */\n\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n\n  return target;\n};\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n\n};\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$4(node, data) {\n  return Object.assign({}, Expression, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref) {\n  let {\n    expressions\n  } = _ref;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$4(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n} // this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\n\n\nconst getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n\n  // template: null,\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find(_ref => {\n      let {\n        id\n      } = _ref;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n    this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = Array.from(this.node.childNodes);\n      moveSlotInnerContent(this.node);\n    }\n\n    removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n};\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method \u00AF\\_(\u30C4)_/\u00AF\n */\n\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n  if (!child) return;\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} options.name - slot id\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref2) {\n  let {\n    name,\n    attributes\n  } = _ref2;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref) => {\n    let {\n      bindings\n    } = _ref;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n};\nfunction create$2(node, _ref2) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref2;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\n\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {Object} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\n\n\nfunction create$1(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || []; // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n}\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {HTMLFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string} html - markup that will be injected into the root node\n * @returns {HTMLFragment} fragment that will be injected into the root node\n */\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\n\n\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null; // create the DOM if it wasn't created before\n\n    this.createDOM(el); // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n\n    const cloneNode = fragment || this.dom.cloneNode(true); // store root node\n    // notice that for template tags the root note will be the parent tag\n\n    this.el = isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$1(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope)); // store the template meta properties\n\n    this.meta = meta;\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.el) {\n      this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n      switch (true) {\n        // pure components should handle the DOM unmount updates by themselves\n        case this.el[IS_PURE_SYMBOL]:\n          break;\n        // <template> tags should be treated a bit differently\n        // we need to clear their children only if it's explicitly required by the caller\n        // via mustRemoveRoot !== null\n\n        case this.children && mustRemoveRoot !== null:\n          clearChildren(this.children);\n          break;\n        // remove the root node only if the mustRemoveRoot === true\n\n        case mustRemoveRoot === true:\n          removeChild(this.el);\n          break;\n        // otherwise we clean the node children\n\n        case mustRemoveRoot !== null:\n          cleanNode(this.el);\n          break;\n      }\n\n      this.el = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      meta: {},\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {Array} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Method used to bind expressions to a DOM node\n * @param   {string|HTMLElement} html - your static template html structure\n * @param   {Array} bindings - list of the expressions to bind to update the markup\n * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods\n *\n * @example\n *\n * riotDOMBindings\n *  .template(\n *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,\n *   [\n *     {\n *       selector: '[expr0]',\n *       redundantAttribute: 'expr0',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.time;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr1]',\n *       redundantAttribute: 'expr1',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.name;\n *           },\n *         },\n *         {\n *           type: 'attribute',\n *           name: 'style',\n *           evaluate(scope) {\n *             return scope.style;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr2]',\n *       redundantAttribute: 'expr2',\n *       type: bindingTypes.IF,\n *       evaluate(scope) {\n *         return scope.isVisible;\n *       },\n *       template: riotDOMBindings.template('hello there'),\n *     },\n *   ]\n * )\n */\n\nvar DOMBindings = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  template: create,\n  createBinding: create$1,\n  createExpression: create$4,\n  bindingTypes: bindingTypes,\n  expressionTypes: expressionTypes\n});\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(_ref => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentShell} componentShell - riot compiler generated object\n * @returns {Object} component like interface\n */\n\nconst memoizedCreateComponent = memoize(createComponent);\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction evaluateInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\n\nconst bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component;\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentShell} componentShell - riot compiler generated object\n * @returns {TemplateChunk} template chunk object\n */\n\n\nfunction componentTemplateFactory(template, componentShell) {\n  const components = createSubcomponents(componentShell.exports ? componentShell.exports.components : {});\n  return template(create, expressionTypes, bindingTypes, name => {\n    // improve support for recursive components\n    if (name === componentShell.name) return memoizedCreateComponent(componentShell); // return the registered components\n\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name);\n  });\n}\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [el] = args; // mark this node as pure element\n\n      el[IS_PURE_SYMBOL] = true;\n      bindDOMNodeToComponentObject(el, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentShell} componentShell - riot compiler generated object\n * @param   {string} componentShell.css - component css\n * @param   {Function} componentShell.template - function that will return the dom-bindings template function\n * @param   {Object} componentShell.exports - component interface\n * @param   {string} componentShell.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(componentShell) {\n  const {\n    css,\n    template,\n    exports,\n    name\n  } = componentShell;\n  const templateFn = template ? componentTemplateFactory(template, componentShell) : MOCKED_TEMPLATE_INTERFACE;\n  return _ref2 => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [PROPS_KEY]: {},\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$4(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]); // avoiding recursive updates\n      // see also https://github.com/riot/riot/issues/2895\n\n      if (!this[IS_COMPONENT_UPDATING]) {\n        this[IS_COMPONENT_UPDATING] = true;\n        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      }\n\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[IS_COMPONENT_UPDATING] = false;\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP$1.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY,\n  COMPONENTS_IMPLEMENTATION_MAP,\n  PLUGINS_SET\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET.add(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET.delete(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponent)(implementation);\n  };\n}\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n/** @type {string} current riot version */\n\nconst version = 'v5.4.5'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  DOMBindings,\n  createComponent,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, pure, register, uninstall, unmount, unregister, version };\n", "import { register, mount } from 'riot';\n\nconst start = (element, position = 'beforeend') => {\n  const selector = element.dataset.target;\n  const where = selector ? document.querySelector(selector) : document.body;\n  const what = element.text.trim().replace(/\\n\\s+/gm, '');\n  where.insertAdjacentHTML(position, what);\n};\n\nvar component = {\n  'css': `simple-component-riot,[is=\"simple-component-riot\"]{ display: block; padding: 2em; background: lightgreen; color: var(--shade2); text-align: center; cursor: pointer; } simple-component-riot.active,[is=\"simple-component-riot\"].active{ background: var(--shade1); color: var(--shade0); } simple-component-riot.active > *,[is=\"simple-component-riot\"].active > *{ color: inherit; } simple-component-riot h1,[is=\"simple-component-riot\"] h1{ color: var(--shade1); } simple-component-riot p,[is=\"simple-component-riot\"] p{ font-size: 0.8em; text-transform: uppercase; }`,\n  'exports': {\n    onBeforeMount() {\n      // initial state\n      this.state = {\n        count: 0,\n        active: false\n      };\n    },\n\n    onMounted() {\n      // the only option to move the children where we want\n      this.$('.children').appendChild(this.root.children[0]);\n    },\n\n    handleClick() {\n      const {\n        count,\n        active\n      } = this.state;\n      this.update({\n        count: count + 1,\n        active: !active\n      });\n    }\n\n  },\n  'template': function (template, expressionTypes, bindingTypes, getComponent) {\n    return template('<h3 expr0=\"expr0\"> </h3><pre expr1=\"expr1\"> </pre><div class=\"children\"></div>', [{\n      'expressions': [{\n        'type': expressionTypes.ATTRIBUTE,\n        'name': 'class',\n        'evaluate': function (scope) {\n          return scope.state.active ? 'active' : null;\n        }\n      }, {\n        'type': expressionTypes.EVENT,\n        'name': 'onclick',\n        'evaluate': function (scope) {\n          return scope.handleClick;\n        }\n      }]\n    }, {\n      'redundantAttribute': 'expr0',\n      'selector': '[expr0]',\n      'expressions': [{\n        'type': expressionTypes.TEXT,\n        'childNodeIndex': 0,\n        'evaluate': function (scope) {\n          return scope.props.title;\n        }\n      }]\n    }, {\n      'redundantAttribute': 'expr1',\n      'selector': '[expr1]',\n      'expressions': [{\n        'type': expressionTypes.TEXT,\n        'childNodeIndex': 0,\n        'evaluate': function (scope) {\n          return ['Clicked: ', scope.state.count, ' times'].join('');\n        }\n      }]\n    }]);\n  },\n  'name': 'simple-component-riot'\n};\n\nregister('simple-component-riot', component);\nstart(document.currentScript);\nmount('simple-component-riot');\n"],
  "mappings": "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",
  "names": []
}
