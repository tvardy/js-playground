{
  "version": 3,
  "sources": ["../src/js/utils/storage.js", "../src/js/_globals.js", "../src/js/tools/Logger.js"],
  "sourcesContent": ["/**\n * A VEEERRY siplified version to polyfill Web Storage if inaccessible\n *\n * Refer to:\n * - https://gist.github.com/jarrodirwin/0ce4c0888336b533b2c4\n * - https://gist.github.com/remy/350433\n */\nconst noop = () => {}\n\nfunction MockedStorage () {\n  return {\n    length: 0,\n    clear: noop,\n    getItem: noop,\n    key: noop,\n    setItem: noop,\n    removeItem: noop\n  }\n}\n\nexport function getStorage (self) {\n  try {\n    // Check for Web Storage existence.\n    if (!self.localStorage || !self.sessionStorage) throw 'no storage!' // eslint-disable-line no-throw-literal\n\n    // Test Web Storage accessibility - Needed for Safari private browsing.\n    self.localStorage.setItem('storage_test', '1')\n    self.localStorage.removeItem('storage_test')\n\n    return [self.localStorage, self.sessionStorage]\n  } catch (e) {\n    // create simple mocked implementations\n    const ls = new MockedStorage()\n    const ss = new MockedStorage()\n\n    return [ls, ss]\n  }\n}\n", "// We needed a global Promise polyfill, because the `whatwg-fetch` expects it\n// import 'promise-polyfill/dist/polyfill.min.js'\n// import 'whatwg-fetch'\n// ** (As I changed the browserslist criteria there's no need for the polyfills anymore)\n\nimport { getStorage } from './utils/storage.js'\n\n/**\n * Note: `window` should only be used directly in cases where it can't be avoided,\n * such as getting and setting window.onerror / window.onunload\n */\n\nconst globals = (function () {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== 'undefined') return self // eslint-disable-line no-undef\n\n  if (typeof global !== 'undefined') return global // eslint-disable-line no-undef\n\n  if (typeof window !== 'undefined') return window // eslint-disable-line no-undef\n\n  throw new Error('unable to locate global object')\n})()\n\n// prevent silent errors for globally exposed PubSub\n// delete globals.PubSub; // TODO: uncomment this line when all global PubSub calls are rewritten\n\nconst [ls, ss] = getStorage(globals)\n\nexport const clearTimeout = globals.clearTimeout.bind(globals)\nexport const console = globals.console\nexport const document = globals.document\nexport const history = globals.history\nexport const Error = globals.Error\nexport const fetch = globals.fetch\nexport const navigator = globals.navigator\nexport const localStorage = ls\nexport const location = globals.location\nexport const JSON = globals.JSON\nexport const Promise = globals.Promise\nexport const setTimeout = globals.setTimeout.bind(globals)\nexport const sessionStorage = ss\nexport const window = globals.window\n\nexport default globals\n", "import { console, localStorage } from '../_globals.js'\n\nconst CONFIG = {\n  DEBUG: 1,\n  INFO: 2,\n  LOG: 3,\n  WARN: 4,\n  ERROR: 5,\n  OFF: 10\n}\n\nexport const LEVELS = Object.keys(CONFIG).reduce((o, key) => {\n  o[key] = key\n  return o\n}, {})\n\nexport class Logger {\n  constructor (key = 'debug') {\n    this._key = key\n\n    let debug = 'false'\n\n    try {\n      debug = localStorage.getItem(this._key) || 'false'\n    } catch (e) {\n      // it seems we should not care as fallback below if localStorage fail in some private mode or sth...\n    }\n\n    // we are forcing setter call\n    this.logLevel = debug\n  }\n\n  get logLevel () {\n    return this._logLevel\n  }\n\n  set logLevel (level) {\n    const name = CONFIG[level] ? level : 'OFF'\n    const value = CONFIG[name]\n\n    this._logLevel = {\n      name,\n      value\n    }\n  }\n\n  debug () {\n    if (this.logLevel.value <= CONFIG.DEBUG) {\n      console.debug(LEVELS.DEBUG, '::', ...arguments)\n    }\n  }\n\n  info () {\n    if (this.logLevel.value <= CONFIG.INFO) {\n      console.info(LEVELS.INFO, '::', ...arguments)\n    }\n  }\n\n  log () {\n    if (this.logLevel.value <= CONFIG.LOG) {\n      console.log(LEVELS.LOG, '::', ...arguments)\n    }\n  }\n\n  warn () {\n    if (this.logLevel.value <= CONFIG.WARN) {\n      console.warn(LEVELS.WARN, '::', ...arguments)\n    }\n  }\n\n  error () {\n    if (this.logLevel.value <= CONFIG.ERROR) {\n      console.error(LEVELS.ERROR, '::', ...arguments)\n    }\n  }\n}\n\nexport const Log = new Logger()\n"],
  "mappings": "ohCAOA,GAAM,GAAO,IAAM,GAEnB,YAA0B,CACxB,MAAO,CACL,OAAQ,EACR,MAAO,EACP,QAAS,EACT,IAAK,EACL,QAAS,EACT,WAAY,GAIT,WAAqB,EAAM,CAChC,GAAI,CAEF,GAAI,CAAC,EAAK,cAAgB,CAAC,EAAK,eAAgB,KAAM,cAGtD,SAAK,aAAa,QAAQ,eAAgB,KAC1C,EAAK,aAAa,WAAW,gBAEtB,CAAC,EAAK,aAAc,EAAK,sBACzB,EAAP,CAEA,GAAM,GAAK,GAAI,GACT,EAAK,GAAI,GAEf,MAAO,CAAC,EAAI,ICvBhB,GAAM,GAAW,UAAY,CAI3B,GAAI,MAAO,OAAS,YAAa,MAAO,MAExC,GAAI,MAAO,SAAW,YAAa,MAAO,QAE1C,GAAI,MAAO,IAAW,YAAa,MAAO,GAE1C,KAAM,IAAI,GAAM,qCAMZ,CAAC,EAAI,GAAM,EAAW,GAEf,EAAe,EAAQ,aAAa,KAAK,GACzC,EAAU,EAAQ,QAClB,EAAW,EAAQ,SACnB,EAAU,EAAQ,QAClB,EAAQ,EAAQ,MAChB,EAAQ,EAAQ,MAChB,EAAY,EAAQ,UACpB,EAAe,EACf,EAAW,EAAQ,SACnB,EAAO,EAAQ,KACf,EAAU,EAAQ,QAClB,EAAa,EAAQ,WAAW,KAAK,GAE3C,GAAM,GAAS,EAAQ,OCzC9B,GAAM,GAAS,CACb,MAAO,EACP,KAAM,EACN,IAAK,EACL,KAAM,EACN,MAAO,EACP,IAAK,IAGM,EAAS,OAAO,KAAK,GAAQ,OAAO,CAAC,EAAG,IACnD,GAAE,GAAO,EACF,GACN,IAEI,OAAa,CAClB,YAAa,EAAM,QAAS,CAC1B,KAAK,KAAO,EAEZ,GAAI,GAAQ,QAEZ,GAAI,CACF,EAAQ,EAAa,QAAQ,KAAK,OAAS,cACpC,EAAP,EAKF,KAAK,SAAW,KAGd,WAAY,CACd,MAAO,MAAK,aAGV,UAAU,EAAO,CACnB,GAAM,GAAO,EAAO,GAAS,EAAQ,MAC/B,EAAQ,EAAO,GAErB,KAAK,UAAY,CACf,OACA,SAIJ,OAAS,CACP,AAAI,KAAK,SAAS,OAAS,EAAO,OAChC,EAAQ,MAAM,EAAO,MAAO,KAAM,GAAG,WAIzC,MAAQ,CACN,AAAI,KAAK,SAAS,OAAS,EAAO,MAChC,EAAQ,KAAK,EAAO,KAAM,KAAM,GAAG,WAIvC,KAAO,CACL,AAAI,KAAK,SAAS,OAAS,EAAO,KAChC,EAAQ,IAAI,EAAO,IAAK,KAAM,GAAG,WAIrC,MAAQ,CACN,AAAI,KAAK,SAAS,OAAS,EAAO,MAChC,EAAQ,KAAK,EAAO,KAAM,KAAM,GAAG,WAIvC,OAAS,CACP,AAAI,KAAK,SAAS,OAAS,EAAO,OAChC,EAAQ,MAAM,EAAO,MAAO,KAAM,GAAG,aAK9B,EAAM,GAAI",
  "names": []
}
