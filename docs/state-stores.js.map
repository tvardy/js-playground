{
  "version": 3,
  "sources": ["../src/js/store.js", "../node_modules/svelte/store/index.mjs", "../src/js/state-stores.js"],
  "sourcesContent": ["import { writable } from 'svelte/store'\nimport { nanoid as uuid } from 'nanoid'\n\nimport initialState from './store-initial-state'\nimport { _noop } from './utils/noop'\n\nconst _state = {\n  ...initialState\n}\n\nfunction createStore () {\n  const { subscribe, update } = writable(_state)\n\n  return {\n    subscribe,\n\n    // actions\n    toggle (id) {\n      update((state) => ({\n        ...state,\n        todos: state.todos.map((item) => {\n          if (item.id === id) {\n            item.done = !item.done\n          }\n          return item\n        })\n      }))\n    },\n    add (text) {\n      update((state) => ({\n        ...state,\n        todos: [{ text, done: false, id: uuid() }, ...state.todos]\n      }))\n    }\n  }\n}\n\nexport const store = createStore()\n\nexport function connect (mapState = _noop, mapActions = _noop) {\n  mapActions(store)\n\n  store.subscribe(mapState)\n}\n", "import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n", "import { init } from './state-common.js'\nimport * as store from './store.js'\nimport SvelteApp from './components/App.svelte'\n\ninit('Svelte stores', store, SvelteApp)\n"],
  "mappings": "2QAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,EAAA,UAAAC,ICGA,IAAMC,EAAmB,CAAC,EAgB1B,SAASC,EAASC,EAAOC,EAAQC,EAAM,CACnC,IAAIC,EACEC,EAAc,IAAI,IACxB,SAASC,EAAIC,EAAW,CACpB,GAAIC,EAAeP,EAAOM,CAAS,IAC/BN,EAAQM,EACJH,GAAM,CACN,IAAMK,EAAY,CAACC,EAAiB,OACpC,QAAWC,KAAcN,EACrBM,EAAW,GAAG,EACdD,EAAiB,KAAKC,EAAYV,CAAK,EAE3C,GAAIQ,EAAW,CACX,QAASG,EAAI,EAAGA,EAAIF,EAAiB,OAAQE,GAAK,EAC9CF,EAAiBE,GAAG,GAAGF,EAAiBE,EAAI,EAAE,EAElDF,EAAiB,OAAS,CAC9B,CACJ,CAER,CACA,SAASG,EAAOC,EAAI,CAChBR,EAAIQ,EAAGb,CAAK,CAAC,CACjB,CACA,SAASc,EAAUC,EAAKC,EAAad,EAAM,CACvC,IAAMQ,EAAa,CAACK,EAAKC,CAAU,EACnC,OAAAZ,EAAY,IAAIM,CAAU,EACtBN,EAAY,OAAS,IACrBD,EAAOF,EAAMI,CAAG,GAAKH,GAEzBa,EAAIf,CAAK,EACF,IAAM,CACTI,EAAY,OAAOM,CAAU,EACzBN,EAAY,OAAS,IACrBD,EAAK,EACLA,EAAO,KAEf,CACJ,CACA,MAAO,CAAE,IAAAE,EAAK,OAAAO,EAAQ,UAAAE,CAAU,CACpC,CDrDA,IAAMG,EAAS,CACb,GAAGC,CACL,EAEA,SAASC,GAAe,CACtB,GAAM,CAAE,UAAAC,EAAW,OAAAC,CAAO,EAAIC,EAASL,CAAM,EAE7C,MAAO,CACL,UAAAG,EAGA,OAAQG,EAAI,CACVF,EAAQG,IAAW,CACjB,GAAGA,EACH,MAAOA,EAAM,MAAM,IAAKC,IAClBA,EAAK,KAAOF,IACdE,EAAK,KAAO,CAACA,EAAK,MAEbA,EACR,CACH,EAAE,CACJ,EACA,IAAKC,EAAM,CACTL,EAAQG,IAAW,CACjB,GAAGA,EACH,MAAO,CAAC,CAAE,KAAAE,EAAM,KAAM,GAAO,GAAIC,EAAK,CAAE,EAAG,GAAGH,EAAM,KAAK,CAC3D,EAAE,CACJ,CACF,CACF,CAEO,IAAMI,EAAQT,EAAY,EAE1B,SAASU,EAASC,EAAWC,EAAOC,EAAaD,EAAO,CAC7DC,EAAWJ,CAAK,EAEhBA,EAAM,UAAUE,CAAQ,CAC1B,CEvCAG,EAAK,gBAAiBC,EAAOC,CAAS",
  "names": ["store_exports", "__export", "connect", "store", "subscriber_queue", "writable", "value", "start", "noop", "stop", "subscribers", "set", "new_value", "safe_not_equal", "run_queue", "subscriber_queue", "subscriber", "i", "update", "fn", "subscribe", "run", "invalidate", "_state", "store_initial_state_default", "createStore", "subscribe", "update", "writable", "id", "state", "item", "text", "nanoid", "store", "connect", "mapState", "_noop", "mapActions", "init", "store_exports", "App_default"]
}
